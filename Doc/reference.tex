\newpage
\leftline{\bf NLClearErrors}
\label{Subroutine:NLClearErrors}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Clears all errors.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLClearErrors();}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine clears the error stack.
\newpage
\leftline{\bf NLCreateElementFunction}
\label{Subroutine:NLCreateElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLElementFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
NLElementFunction NLCreateElementFunction(NLProblem P,char *type,int n,NLMatrix
R,double (*f)(int,double*,void*),double (*df)(int,int,double*,void*),double (*dd
f)(int,int,int,double*,void*),void *data,void (*freedata)(void*));

\leftline{\tt {\it F}=NLCreateElementFunction({\it P},{\it type},{\it n},{\it R},{\it f},{\it df},{\it ddf},{\it data}{\it freeData});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction \it F&\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char *\it type&\parbox[t]{\SYNTAX}{The type given to the new element function.}\\
\tt int {\it n}&\parbox[t]{\SYNTAX}{The number of element variables.}\\
\tt NLMatrix {\it R}&\parbox[t]{\SYNTAX}{The range transformation, or (NLMatrix)NULL if the identity.}\\
\tt double {\it f}\tt (int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the function.}\\
\tt double {\it df}\tt (int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the derivative of the function.}\\
\tt double {\it ddf}\tt (int,int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the second derivative of the function.}\\
\tt void {\it *data}&\parbox[t]{\SYNTAX}{A pointer to user specific data which will be passed to the function.}\\
\tt void {\it (*freeData)(void*)}&\parbox[t]{\SYNTAX}{A pointer to a routine to free user specific data, or (void (*)(void*)NULL). Will be called when the element function is deleted.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreateElementFunction} allocates and initializes an NLElementFunction data structure.

The NLElementFunction data structure uses reference counting.
The data structure should be deleted using the {\tt NLFreeElementFunction} subroutine 
(page \pageref{Subroutine:NLFreeElementFunction}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRefElementFunction} subroutine (page 
\pageref{Subroutine:NLRefElementFunction}).
\vskip .1in
\leftline{\bf Errors}
Errors return (NLElementFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{5.in}{"Number of coordinates is not positive \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateGroupFunction}
\label{Subroutine:NLCreateGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLGroupFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it G}=NLCreateGroupFunction({\it P},{\it type},{\it g},{\it dg},{\it ddg},{\it data},{\it freeData});}
\vskip .1in
\begin{tabular}{lll}
\tt NLGroupFunction \it G &\parbox[t]{\SYNTAX}{The group function.}\\
\tt NLProblem \it P &\parbox[t]{\SYNTAX}{The problem to which the group function belongs.}\\
\tt char *\it type &\parbox[t]{\SYNTAX}{A name associated to the group function.}\\
\tt double {\it g}\tt (double,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the function.}\\
\tt double {\it dg}\tt (double,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the derivative of the function.}\\
\tt double {\it ddg}\tt (double,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the second derivative of the function.}\\
\tt void {\it *data}&\parbox[t]{\SYNTAX}{A pointer to user specific data which is to be provided to the function.}\\
\tt void {\it (*freeData)(void*)}&\parbox[t]{\SYNTAX}{A pointer to a routine to free user specific data, or (void (*)(void*)NULL). Will be called when the element function is deleted.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Group\-Function} allocates and initializes an NLGroupFunction data structure.

The NLGroupFunction data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Group\-Function} subroutine 
(page \pageref{Subroutine:NLFreeGroupFunction}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt LNRef\-Group\-Function} subroutine (page 
\pageref{Subroutine:NLRefGroupFunction}).
\vskip .1in
\leftline{\bf Errors}
Errors return (NLGroupFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateLancelot}
\label{Subroutine:NLCreateLancelot}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLLancelot data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it Lan}=NLCreateLancelot();}
\vskip .1in
\begin{tabular}{lll}
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Lancelot} allocates and initializes an NLLancelot data structure.
The solver returned has default parameters values, which 
can be set with various subroutines. Multiple instances are
legal.

The storage used by the solver can be returned to the system
using the {\tt NLFree\-Lancelot} subroutine (page 
\pageref{Subroutine:NLFreeLancelot}).\vskip .1in
\leftline{\bf Errors}
Errors return (NLLancelot)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateMatrix}
\label{Subroutine:NLCreateMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLMatrix data structure of a given 
size.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it A}=NLCreateMatrix({\it n},{\it m});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of rows in the matrix.}\\
\tt int&\it m &\parbox[t]{\SYNTAX}{The number of columns in the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Matrix} allocates and initializes an NLMatrix data structure of 
a given size. The matrix returned has all elements zero, until 
they are set with the {\tt LNMSet\-Element} routine (page 
\pageref{Subroutine:NLMSetElement}). The {\tt NLCreate\-Matrix\-With\-Data} 
subroutine (page \pageref{Subroutine:NLCreateMatrixWithData})
can be used to created Matrices with supplied elements.

The NLMatrix data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Matrix} subroutine 
(page \pageref{Subroutine:NLFreeMatrix}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt LNRef\-Matrix} subroutine (page 
\pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Number of rows \%d (argument 1) is negative."}&12\\
\parbox[t]{5.in}{"Number of columns \%d (argument 2) is negative."}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%dx\%d matrix (\%d bytes)"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateSparseMatrix}
\label{Subroutine:NLCreateSparseMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLMatrix data structure of a given 
size.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it A}=NLCreateSparseMatrix({\it n},{\it m});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of rows in the matrix.}\\
\tt int&\it m &\parbox[t]{\SYNTAX}{The number of columns in the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Sparse\-Matrix} allocates and initializes a sparse NLMatrix data structure of a given size. Only the non-zeros are stored.
The matrix returned has all elements zero, until 
they are set with the {\tt LNMSet\-Element} routine (page 
\pageref{Subroutine:NLMSetElement}), or incremented by the {\tt LNMIncrement\-Element} routine (page
\pageref{Subroutine:NLMIncrementElement}).

The NLMatrix data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Matrix} subroutine 
(page \pageref{Subroutine:NLFreeMatrix}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt LNRef\-Matrix} subroutine (page 
\pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Number of rows \%d (argument 1) is negative."}&12\\
\parbox[t]{5.in}{"Number of columns \%d (argument 2) is negative."}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%dx\%d matrix (\%d bytes)"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateMatrixWithData}
\label{Subroutine:NLCreateMatrixWithData}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLMatrix data structure of a given 
size with given elements.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it A}=NLCreateMatrixWithData({\it n},{\it m},{\it aij});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of rows in the matrix.}\\
\tt int&\it m &\parbox[t]{\SYNTAX}{The number of columns in the matrix.}\\
\tt double&*\it aij &\parbox[t]{\SYNTAX}{The entries of the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Matrix} allocates and initializes an NLMatrix data structure of 
a given size with given elements. The elements may be changed later 
with the {\tt LNMSet\-Element} routine (page 
\pageref{Subroutine:NLMSetElement}). Zero Matrices can 
be created with the
{\tt NLCreate\-Matrix} subroutine (page \pageref{Subroutine:NLCreateMatrix}).

The NLMatrix data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Matrix} subroutine 
(page \pageref{Subroutine:NLFreeMatrix}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt LNRef\-Matrix} subroutine (page 
\pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Severity 12 errors return (NLMatrix)NULL.
Severity 4 errors return a matrix with all entries zero.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Number of rows (argument 1) is negative \%d"}&12\\
\parbox[t]{5.in}{"Number of columns (argument 2) is negative \%d"}&12\\
\parbox[t]{5.in}{"Pointer to data (argument 3) is NULL"}&4\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%dx\%d matrix (\%d bytes)"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateNonlinearElement}
\label{Subroutine:NLCreateNonlinearElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLElementFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}

\leftline{\tt {\it NE}=NLCreateNonlinearElement({\it P},{\it type},{\it fn},{\it vars});}
\vskip .1in
\begin{tabular}{lll}
\tt NLNonlinearElement\it NE&\parbox[t]{\SYNTAX}{The new nonlinear element.}\\
\tt NLProblem {\it P}&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char *{\it type}&\parbox[t]{\SYNTAX}{The type given to the new nonlinear element.}\\
\tt NLElementFuntion {\it fn}&\parbox[t]{\SYNTAX}{The element function for the new nonlinear element.}\\
\tt int *{\it vars}&\parbox[t]{\SYNTAX}{A list of the element variables for the new nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreateNonlinearElement} allocates and initializes an NLNonlinearElement data structure.

The NLNonlinearElement data structure uses reference counting.
The data structure should be deleted using the {\tt NLFreeNonlinearElement} subroutine 
(page \pageref{Subroutine:NLFreeNonlinearElement}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRefNonlinearElement} subroutine (page 
\pageref{Subroutine:NLRefNonlinearElement}).
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL."}&12\\
\parbox[t]{5.in}{"Element Function (argument 3) is NULL."}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateProblem}
\label{Subroutine:NLCreateProblem}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLProblem data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it P}=NLCreateProblem({\it probName},{\it nV});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char &*{\it probName}&\parbox[t]{\SYNTAX}{The problem name, used by Lancelot on reports.}\\
\tt int &{\it nV}&\parbox[t]{\SYNTAX}{The number of variables in the problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Problem} allocates and initializes an NLProblem data structure.
The problem as initialized has no nonlinear constraints, no bounds
on the variables or objective, and no groups in the objective. Note that this
is not a valid problem. Lancelot will be invoked, but will issue an error 
unles a group is added to the objective. 

A problem should be deleted using the routine {\tt NLFree\-Problem} 
(page \pageref{Subroutine:NLFreeProblem}) when
it is no longer needed. This returns all storage used by the problem.\vskip .1in
\leftline{\bf Errors}
Severity 12 errors return (NLProblem)NULL, severity 4 returns a problem with no
name.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem name (argument 1) is NULL"}&4\\
\parbox[t]{5.in}{"Number of Variables \%d (argument 2) must be positive"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateVector}
\label{Subroutine:NLCreateVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLVector data structure of a given length.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLCreateVector({\it n});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The length of the vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Vector} allocates an NLVector data structure and initializes
it to a vector of given length with no non-zero coordinates. The coordinates
may be changed with the {\tt LNVSet\-C} routine (page 
\pageref{Subroutine:NLVSetC}). Vectors with supplied coordinate values can 
be created with the {\tt NLCreate\-Vector\-With\-Sparse\-Data} and 
{\tt NLCreate\-Vector\-With\-Full\-Data} subroutines (pages \pageref{Subroutine:NLCreateVectorWithSparseData} and \pageref{Subroutine:NLCreateVectorWithFullData}).

The NLVector data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Vector} subroutine 
(page \pageref{Subroutine:NLFreeVector}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt LNRef\-Vector} subroutine (page 
\pageref{Subroutine:NLRefVector}).
\vskip .1in
\leftline{\bf Errors}
Severity 12 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Length of Vector \%d (argument 1) is Illegal. Must be positive."}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateVectorWithFullData}
\label{Subroutine:NLCreateVectorWithFullData}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLVector data structure of a given length.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLCreateVectorWithFullData({\it n},{\it vl});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The length of the vector.}\\
\tt double& *\it vl &\parbox[t]{\SYNTAX}{The values of the coordinates.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
This routine, {\tt NLCreate\-Vector\-With\-Full\-Data} returns an 
NLVector data structure of a given length and coordinates. The vector 
returned has all coordinates marked as non-zero. 

The coordinates may be changed using the {\tt LNVSet\-C} routine 
(page \pageref{Subroutine:NLVSetC}). Zero vectors and sparse vectors
can be created with the {\tt NLCreate\-Vector} (page 
\pageref{Subroutine:NLCreateVector}) and 
{\tt NLCreate\-Vector\-With\-Sparse\-Data} (page 
\pageref{Subroutine:NLCreateVectorWithSparseData}) subroutines.

Note that the coordinates and values are copied out of the {\it vl} array,
so subsequent changes to it do not effect the vector.

The NLVector data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Vector} subroutine 
(page \pageref{Subroutine:NLFreeVector}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt LNRef\-Vector} subroutine (page 
\pageref{Subroutine:NLRefVector}).
\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return a vector with no nonzero coordinates.
Severity 12 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Length of Vector \%d (argument 1) is Illegal. Must be positive."}&12\\
\parbox[t]{5.in}{"The pointer to the array of coordinates (argument 2) is NULL"}&4\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateVectorWithSparseData}
\label{Subroutine:NLCreateVectorWithSparseData}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLVector data structure of a given length.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLCreateVectorWithSparseData({\it n},{\it nz},{\it el},{\it vl});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector &\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int &\it n &\parbox[t]{\SYNTAX}{The length of the vector.}\\
\tt int &\it nz &\parbox[t]{\SYNTAX}{The number of non-zeros in the vector.}\\
\tt int &*\it el &\parbox[t]{\SYNTAX}{The indices of the non-zero coordinates.}\\
\tt double &*\it vl &\parbox[t]{\SYNTAX}{The values of the non-zero coordinates.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine,
{\tt NLCreate\-Vector\-With\-Sparse\-Data} allocates and initializes an NLVector data 
structure of a given length and coordinates. The vector returned has {\it nz}
non-zero coordinates, given in the list {\it el} and with values from the 
array {\it vl}. The coordinates may be changed using the {\tt LNVSet\-C} routine 
(page \pageref{Subroutine:NLVSetC}). Zero vectors and vectors with no non-zero
coordinates can be created with the {\tt NLCreate\-Vector} 
(page \pageref{Subroutine:NLCreateVectorWithSparseData})
and 
{\tt NLCreate\-Vector\-With\-Full\-Data} 
(page \pageref{Subroutine:NLCreateVectorWithFullData})
subroutines.

Note that the coordinates and values are copied out of the arrays,
so subsequent changes to the {\it el} and {\it vl} arrays do not effect the
vector.

The NLVector data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Vector} subroutine 
(page \pageref{Subroutine:NLFreeVector}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt LNRef\-Vector} subroutine (page 
\pageref{Subroutine:NLRefVector}).
\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return a vector with no nonzero coordinates.
Severity 12 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Length of Vector \%d (argument 1) is Illegal. Must be positive."}&12\\
\parbox[t]{5.in}{"Number of nonzeros in vector \%d (argument 2) is Illegal. Must be nonnegative."}&12\\
\parbox[t]{5.in}{"The pointer to the array of nonZeros (argument 3) is NULL"}&4\\
\parbox[t]{5.in}{"The pointer to the array of coordinates (argument 4) is NULL"}&4\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
NLVector NLCreateDenseWrappedVector(int n,double *data)
\newpage
\leftline{\bf NLCreateDenseWrappedVector}
\label{Subroutine:NLCreateDenseWrappedVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLVector data structure of a given length with data at a given storage 
location.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLCreateDenseWrappedVector({\it n}, {\it data});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The length of the vector.}\\
\tt double*&\it data &\parbox[t]{\SYNTAX}{The buffer for the coordinates of the vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-DenseWrappedVector} allocates an NLVector data structure and sets
the coordinates to reference a given buffer. The coordinates
may be changed with the {\tt LNVSet\-C} routine (page 
\pageref{Subroutine:NLVSetC}) or by changing the buffer. 

The NLVector data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Vector} subroutine 
(page \pageref{Subroutine:NLFreeVector}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt LNRef\-Vector} subroutine (page 
\pageref{Subroutine:NLRefVector}).
\vskip .1in
\leftline{\bf Errors}
Severity 12 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Length of Vector \%d (argument 1) is Illegal. Must be positive."}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLEEval}
\label{Subroutine:NLEEval}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates an NLElementFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLEEval({\it F},{\it n},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it f &\parbox[t]{\SYNTAX}{The value of the element function.}\\
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of coordinates.}\\
\tt double &*\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of a element function $f(x)$.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Element Function (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Number of arguments to Element Function \%d is illegal (argument 2). Must be \%d. Argument 1 is \%8.8x"}&12\\
\parbox[t]{5.in}{"Pointer to x (argument 3) is NULL. F is \%8.8x"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLEEvalDer}
\label{Subroutine:NLEEvalDer}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the derivative of an NLElementFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLEEvalDer({\it F},{\it i},{\it n},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it f &\parbox[t]{\SYNTAX}{The value of the derivative.}\\
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The first variable.}\\
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of coordinates in the point.}\\
\tt double &*\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of the derivative of a element function ${\rm d}f(x)/{\rm dx_i}$.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Element Function (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Direction \%d (argument 2) is illegal. Must be in range 0 to \%d Argument 1 is \%8.8x"}&12\\
\parbox[t]{5.in}{"Number of arguments to Element Function \%d is illegal (argument 3). Must be \%d. Argument 1 is \%8.8x"}&12\\
\parbox[t]{5.in}{"Pointer to x (argument 4) is NULL. F is \%8.8x"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLEEvalSecDer}
\label{Subroutine:NLEEvalSecDer}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the second derivative of an NLElementFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLEEvalSecDer({\it F},{\it i},{\it j},{\it n},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it f &\parbox[t]{\SYNTAX}{The value of the second derivative.}\\
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The first variable.}\\
\tt int &\it j &\parbox[t]{\SYNTAX}{The second variable.}\\
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of coordinates in the point.}\\
\tt double &*\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of the second derivative of a element function ${\rm d}^2f(x)/{\rm dx_i}/{\rm dx_j}$.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Element Function (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Direction \%d (argument 2) is illegal. Must be in range 0 to \%d Argument 1 is \%8.8x"}&12\\
\parbox[t]{5.in}{"Direction \%d (argument 3) is illegal. Must be in range 0 to \%d Argument 1 is \%8.8x"}&12\\
\parbox[t]{5.in}{"Number of arguments to Element Function \%d is illegal (argument 4). Must be \%d. Argument 1 is \%8.8x"}&12\\
\parbox[t]{5.in}{"Pointer to x (argument 5) is NULL. F is \%8.8x"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLEGetDimension}
\label{Subroutine:NLEGetDimension}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of unknowns (element internal variables) for an NLElementFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLEGetDimension({\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of unknowns.}\\
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of unknowns for an element function.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Element Function (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLError}
\label{Subroutine:NLError}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether an error condition exists.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLError();}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine checks to see if any routine has set an error condition.
\newpage
\leftline{\bf NLFreeElementFunction}
\label{Subroutine:NLFreeElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLElementFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeElementFunction({\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLElementFunction data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero.  The {\tt LNRef\-Element\-Function} 
subroutine (page \pageref{Subroutine:NLRefElementFunction})
may be used to add References.
\vskip .1in
\leftline{\bf Errors}
Errors return without chaning the element function.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Element Function (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLFreeGroupFunction}
\label{Subroutine:NLFreeGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLGroupFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeGroupFunction({\it G});}
\vskip .1in
\begin{tabular}{lll}
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLGroupFunction data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero. The {\tt LNRef\-Group\-Function} 
subroutine (page \pageref{Subroutine:NLRefGroupFunction})
may be used to add references.
\vskip .1in
\leftline{\bf Errors}
Errors return with changing the group function.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Group Function (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLFreeLancelot}
\label{Subroutine:NLFreeLancelot}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Releases storage associated with an NLLancelot data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeLancelot({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLFree\-Lancelot} returns storage associated with a solver to the system.\vskip .1in
\leftline{\bf Errors}
Errors return without changing the solver.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLFreeMatrix}
\label{Subroutine:NLFreeMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLMatrix data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeMatrix({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLMatrix data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero. References may be added using the {\tt LNRef\-Matrix} 
subroutine (page \pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Error returns without changing the matrix.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Matrix (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLFreeNonlinearElement}
\label{Subroutine:NLFreeNonlinearElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLNonlinearElement data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeNonlinearElement({\it P},{\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLNonlinearElement data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero.  The {\tt LNRef\-Nonlinear\-Element} 
subroutine (page \pageref{Subroutine:NLRefNonlinearElement})
may be used to add References.
\vskip .1in
\leftline{\bf Errors}
Errors return without chaning the element function.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Nonlinear Element (argument 2) is invalid, "}&12\\
\end{tabular}
\newpage
\leftline{\bf NLFreeProblem}
\label{Subroutine:NLFreeProblem}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Releases storage associated with an NLProblem data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeProblem({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLFree\-Problem} returns storage associated with a problem to the system.\vskip .1in
\leftline{\bf Errors}
Errors return without changing the problem.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLFreeVector}
\label{Subroutine:NLFreeVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLVector data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeVector({\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector &\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLVector data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero. References may be added using the {\tt LNRef\-Vector} 
subroutine (page \pageref{Subroutine:NLRefVector}).\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return without changing the vector.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLGEval}
\label{Subroutine:NLGEval}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates an NLGroupFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLGEval({\it G},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it g &\parbox[t]{\SYNTAX}{The value of the group function.}\\
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\tt double &\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of a group function $g(x)$.
\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Group Function (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group Function function is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLGEvalDer}
\label{Subroutine:NLGEvalDer}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the derivative of an NLGroupFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLGEvalDer({\it G},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it g &\parbox[t]{\SYNTAX}{The value of the derivative.}\\
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\tt double &\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of the derivative of a group function ${\rm d}g(x)/{\rm dx}$.
\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\
\hline
\parbox[t]{5.in}{"Group Function (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group Function Derivative function is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLGEvalSecDer}
\label{Subroutine:NLGEvalSecDer}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the second derivative of an NLGroupFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLGEvalSecDer({\it G},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it g &\parbox[t]{\SYNTAX}{The value of the second derivative.}\\
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\tt double &\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of the second derivative of a group function ${\rm d}g(x)/{\rm dx}$.
\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Group Function (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group Function Second Derivative function is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetCheckDerivatives}
\label{Subroutine:LNGetCheckDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot test derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it flag}=LNGetCheckDerivatives({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it flag &\parbox[t]{\SYNTAX}{How to test.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Check\-Derivatives} 
gets the parameter controlling how Lancelot test derivatives.
Legal values for the flag and their meaning --
\begin{center}
\begin{tabular}{ll}
0&No checking\\
1&Check all derivatives\\
2&Check derivatives\\
3&Check element derivatives\\
4&Check group derivatives\\
\end{tabular}
\end{center}
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetConstraintAccuracy}
\label{Subroutine:LNGetConstraintAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how accurately Lancelot solves constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it limit}=LNGetConstraintAccuracy({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Constraint\-Accuracy} 
gets the parameter controlling how accurately Lancelot solves the constraints.
The default value is 0.00001.
The {\tt SPEC.SPC} file entry this gets is {\tt CONSTRAINT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLGetErrorFile}
\label{Subroutine:NLGetErrorFile}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the file containing the source code from which an error was issued.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it file}=NLGetErrorFile({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it file &\parbox[t]{\SYNTAX}{The file.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the file containing the source code from which the $i$th error was issued.
\newpage
\leftline{\bf NLGetErrorLine}
\label{Subroutine:NLGetErrorLine}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the statement at which an error occurred.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it stmt}=NLGetErrorLine({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it stmt &\parbox[t]{\SYNTAX}{The statement.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the statement at which the $i$th error occured.
\newpage
\leftline{\bf NLGetErrorMsg}
\label{Subroutine:NLGetErrorMsg}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the message associated with an error.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it msg}=NLGetErrorMsg({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it msg &\parbox[t]{\SYNTAX}{The message text.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the message associated with the $i$th error.
\newpage
\leftline{\bf NLGetErrorRoutine}
\label{Subroutine:NLGetErrorRoutine}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of the routine that issued an error.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it routine}=NLGetErrorRoutine({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it routine &\parbox[t]{\SYNTAX}{The name of the routine.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of the routine which issued the $i$th error.
\newpage
\leftline{\bf NLGetErrorSev}
\label{Subroutine:NLGetErrorSev}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the severity of an error.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it sev}=NLGetErrorSev({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it sev &\parbox[t]{\SYNTAX}{The severity.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the severity of the $i$th error.
\newpage
\leftline{\bf LNGetFirstConstraintAccuracy}
\label{Subroutine:LNGetFirstConstraintAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the initial accuracy Lancelot uses for the constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it acc}=LNGetFirstConstraintAccuracy({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it acc &\parbox[t]{\SYNTAX}{The accuracy.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-First\-Constraint\-Accuracy} 
gets the parameter controlling the initial accuracy Lancelot uses for the constraints.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this gets is {\tt FIRST-CONSTRAINT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetFirstGradientAccuracy}
\label{Subroutine:LNGetFirstGradientAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the initial accuracy for the gradients.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it acc}=LNGetFirstGradientAccuracy({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it acc &\parbox[t]{\SYNTAX}{The accuracy.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-First\-Gradient\-Accuracy} 
gets the parameter controlling the initial accuracy for the gradients.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this corresponds to is {\tt FIRST-GRADIENT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetGradientAccuracy}
\label{Subroutine:LNGetGradientAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the accuracy for the gradients.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it limit}=LNGetGradientAccuracy({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Gradient\-Accuracy} 
gets the parameter controlling the accuracy for the gradients.
The default value is 0.00001.
The {\tt SPEC.SPC} file entry this corresponds to is {\tt GRADIENT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetInitialPenalty}
\label{Subroutine:LNGetInitialPenalty}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the initial penalty.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it penalty}=LNGetInitialPenalty({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it penalty &\parbox[t]{\SYNTAX}{The penalty.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet}\-{\tt Initial}\-{\tt Penalty} 
gets the parameter controlling the initial penalty.
The default value is 0.
The {\tt SPEC.SPC} file entry this sets is\hfill\break
{\tt INITIAL-PENALTY-PARAMETER}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetJiffyTuneTolerance}
\label{Subroutine:LNGetJiffyTuneTolerance}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the ``Jiffytune Tolerance''. {\bf NOTE:} this requires a modified version of Lancelot.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it value}=LNGetJiffyTuneTolerance({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it value &\parbox[t]{\SYNTAX}{Tolerance.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-JiffyTune\-Tolerance} 
gets the parameter controlling the ``Jiffytune Tolerance''.
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetLinearSolverBandwidth}
\label{Subroutine:LNGetLinearSolverBandwidth}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter determining what bandwidth the linear solver uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it bandwidth}=LNGetLinearSolverBandwidth({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it bandwidth &\parbox[t]{\SYNTAX}{The bandwidth.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Linear\-Solver\-Bandwidth} 
gets the parameter determining what bandwidth the linear solver uses.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetLinearSolverMethod}
\label{Subroutine:LNGetLinearSolverMethod}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter determining what linear solver is used.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt int {\it choice}=LNGetLinearSolverMethod({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Linear\-Solver\-Method} 
gets the parameter determining what linear solver is used.
If a banded solver is used, the bandwidth can be retrieved with the
{\tt LNGet\-Linear\-Solver\-Bandwidth} routine (page \pageref{Subroutine:LNGetLinearSolverBandwidth}).

Legal values of {\it choice}, and the corresponding
{\tt SPEC.SPC} file entries are
\begin{center}
 \begin{tabular}{l}
  "Diagonal preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt DIAGONAL-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Munksgaards preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt MUNKSGAARDS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Expanding band preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt EXPANDING-BAND-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Full matrix preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt FULL-MATRIX-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Gill-Murray-Ponceleon-Saunders preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt GILL-MURRAY-PONCELEON-SAUNDERS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Modified MA27 preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt MODIFIED-MA27-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Schnabel-Eskow preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt SCHNABEL-ESKOW-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Users preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt USERS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Bandsolver preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt BANDSOLVER-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Multifront"\\
  \parbox[t]{5.in}{\hfill\tt MULTIFRONT-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Direct modified"\\
  \parbox[t]{5.in}{\hfill\tt DIRECT-MODIFIED-MULTIFRONTAL-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "CG method used"\\
  \parbox[t]{5.in}{\hfill\tt CG-METHOD-USED}\\
 \end{tabular}
\end{center}\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetMaximumNumberOfIterations}
\label{Subroutine:LNGetMaximumNumberOfIterations}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how long Lancelot runs.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetMaximumNumberOfIterations({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{Maximum number of iterations.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Maximum\-Number\-Of\-Iterations} 
sets the parameter controlling how long Lancelot runs.
The default value is 100.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLGetNErrors}
\label{Subroutine:NLGetNErrors}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of errors that have been flagged.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLGetNErrors();}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of errors.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of errors that have been set.
\newpage
\leftline{\bf LNGetPenaltyBound}
\label{Subroutine:LNGetPenaltyBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the bound on the penalty Lancelot uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void {\it penalty}=LNGetPenaltyBound({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it penalty &\parbox[t]{\SYNTAX}{The bound.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Penalty\-Bound} 
gets the parameter controlling the bound on the penalty Lancelot uses.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is\hfill\break
{\tt DECREASE-PENALTY-PARAMETER-UNTIL}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetPrintEvery}
\label{Subroutine:LNGetPrintEvery}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how often Lancelot prints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetPrintEvery({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Print\-Every} 
sets the parameter controlling how often Lancelot prints.
The default value is 1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetPrintLevel}
\label{Subroutine:LNGetPrintLevel}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how much output Lancelot produces.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it level}=LNGetPrintLevel({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it level &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Print\-Level} 
\noindent Gets the parameter controlling how Lancelot how much output Lancelot produces.
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetPrintStart}
\label{Subroutine:LNGetPrintStart}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling when Lancelot starts printing.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetPrintStart({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Print\-Start} 
sets the parameter controlling when Lancelot starts printing.
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetPrintStop}
\label{Subroutine:LNGetPrintStop}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling when Lancelot stops printing.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetPrintStop({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LN\-Get\-Print\-Stop} 
sets the parameter controlling when Lancelot stops printing.
The default value is 100.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetRequireExactCauchyPoint}
\label{Subroutine:LNGetRequireExactCauchyPoint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter determining whether an exact cauchy point is required.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it choice}=LNGetRequireExactCauchyPoint({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Require\-Exact\-Cauchy\-Point} 
gets the parameter determining whether an exact cauchy point is required.
The default is 1.

The corresponding {\tt SPEC.SPC} file entries are {\tt EXACT-CAUCHY-POINT-REQUIRED}
\hfill\break
and {\tt INEXACT-CAUCHY-POINT-REQUIRED}.
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetSaveDataEvery}
\label{Subroutine:LNGetSaveDataEvery}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how often Lancelot saves data.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetSaveDataEvery({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Save\-Data\-Every} 
sets the parameter controlling how often Lancelot saves data.
The default value is 0 (don't save).\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetScalings}
\label{Subroutine:LNGetScalings}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot uses scalings.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it choice}=LNGetScalings({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it choice &\parbox[t]{\SYNTAX}{How to use scalings.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Scalings} 
gets the parameter controlling how Lancelot uses scalings.

The legal values for {\it choice} and the corresponding 
{\tt SPEC.SPC} file entries are
\begin{center}
\begin{tabular}{ll}
   "no scaling"&USE-SCALING-FACTORS\\
   "scale constraints"&USE-CONSTRAINT-SCALING-FACTORS\\
   "scale variables"&USE-VARIABLE-SCALING-FACTORS\\
   "scale both"&USE-SCALING-FACTORS\\
   "print but don't use"&PRINT-SCALING-FACTORS\\
\end{tabular}
\end{center}\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetSolveBQPAccurately}
\label{Subroutine:LNGetSolveBQPAccurately}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the solution of the BQP.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt  {\it choice}=LNGetSolveBQPAccurately({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Solve\-BQP\-Accurately} 
gets the parameter controlling the solution of the BQP.
The default is 0.

The corresponding {\tt SPEC.SPC} file entry is {\tt SOLVE-BQP-ACCURATELY}.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetStopOnBadDerivatives}
\label{Subroutine:LNGetStopOnBadDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot deals with bad derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void LNGetStopOnBadDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Stop\-On\-Bad\-Derivatives} 
\noindent Gets the parameter controlling how Lancelot deals with bad derivatives.
Legal values for the flag and their meaning --
\begin{center}
\begin{tabular}{ll}
0&stop on warning\\
1&stop on element derivative warning\\
2&stop on group derivative warning\\
\end{tabular}
\end{center}
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetTrustRegionRadius}
\label{Subroutine:LNGetTrustRegionRadius}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the radius of the trust region.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it radius}=LNGetTrustRegionRadius({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it radius &\parbox[t]{\SYNTAX}{The radius.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Trust\-Region\-Radius} 
gets the parameter controlling the radius of the trust region.
The default value is 0.
The {\tt SPEC.SPC} file entry this gets is {\tt TRUST-REGION-RADIUS}.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetTrustRegionType}
\label{Subroutine:LNGetTrustRegionType}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the type of trust region Lancelot uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it choice}=LNGetTrustRegionType({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it choice &\parbox[t]{\SYNTAX}{Which type.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Trust\-Region\-Type} 
gets the parameter controlling the type of trust region Lancelot uses.
Legal values for the {\it choice} and their meaning --
\begin{center}
\begin{tabular}{ll}
"two norm"&TWO-NORM-TRUST-REGION-USED\\
"infinity norm"&INFINITY-NORM-TRUST-REGION-USED\\
\end{tabular}
\end{center}
The default value is "infinity norm".\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetUseExactFirstDerivatives}
\label{Subroutine:LNGetUseExactFirstDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot gets derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it flag}=LNGetUseExactFirstDerivatives({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Use\-Exact\-First\-Derivatives} 
gets the parameter controlling how Lancelot gets derivatives. If
flag is 0, differencing is used, otherwise exact derivatives are 
expected.
The default value is 1 (exact derivatives). The {\tt SPEC.SPC} entry this
gets is the logical negative of {\tt FINITE-DIFFERENCE-GRADIENTS}.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetUseExactSecondDerivatives}
\label{Subroutine:LNGetUseExactSecondDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot gets second derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it flag}=LNGetUseExactSecondDerivatives({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Use\-Exact\-Second\-Derivatives} 
gets the parameter controlling gets second derivatives. If
flag is 0, differencing is used, otherwise exact second derivatives are 
expected.
The default value is 1 (exact second derivatives). The {\tt SPEC.SPC} entry this
gets is {\tt EXACT-SECOND-DERIVATIVES-USED}.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}

\newpage
\leftline{\bf NLMGetElement}
\label{Subroutine:NLMGetElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns an element of an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it aij}=NLMGetElement({\it A},{\it i},{\it j});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it aij &\parbox[t]{\SYNTAX}{The element of the matrix.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The row index of the element.}\\
\tt int &\it j &\parbox[t]{\SYNTAX}{The column index of the element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the specified element of the matrix. This is set 
when the matrix is created, or with the {\tt LNMSet\-Element} routine
(page \pageref{Subroutine:NLMSetElement}).\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Matrix (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Row index \%d (argument 2) is negative."}&12\\
\parbox[t]{5.in}{"Row index \%d (argument 2) is too large. Must be less than \%d"}&12\\
\parbox[t]{5.in}{"Column index \%d (argument 3) is negative".}&12\\
\parbox[t]{5.in}{"Column index \%d (argument 3) is too large. Must be less than \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMGetNumberOfCols}
\label{Subroutine:NLMGetNumberOfCols}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of columns in an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it m}=NLMGetNumberOfCols({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it m &\parbox[t]{\SYNTAX}{The number of columns.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of columns in the matrix. This is set 
when the matrix is created.
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Matrix (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMGetNumberOfRows}
\label{Subroutine:NLMGetNumberOfRows}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of rows in an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLMGetNumberOfRows({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of rows.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of rows in the matrix. This is set 
when the matrix is created.
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Matrix (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMSetElement}
\label{Subroutine:NLMSetElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Changes the value of an element of an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLMSetElement({\it A},{\it i},{\it j},{\it aij});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The row index of the element.}\\
\tt int &\it j &\parbox[t]{\SYNTAX}{The column index of the element.}\\
\tt double &\it aij &\parbox[t]{\SYNTAX}{The element of the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the specified element of the matrix.\vskip .1in
\leftline{\bf Errors}
Errors return 0, with no changes to the matrix. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Matrix (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Row index \%d (argument 2) is negative."}&12\\
\parbox[t]{5.in}{"Row index \%d (argument 2) is too large. Must be less than \%d"}&12\\
\parbox[t]{5.in}{"Column index \%d (argument 3) is negative".}&12\\
\parbox[t]{5.in}{"Column index \%d (argument 3) is too large. Must be less than \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMIncrementElement}
\label{Subroutine:NLMIncrementElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Increments the value of an element of an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLMIncrementElement({\it A},{\it i},{\it j},{\it aij});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The row index of the element.}\\
\tt int &\it j &\parbox[t]{\SYNTAX}{The column index of the element.}\\
\tt double &\it aij &\parbox[t]{\SYNTAX}{The increment element of the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the specified element of the matrix, by adding the
specified increment. If the matrix is sparse, and the element does not have
a value, the value is set to the increment.\vskip .1in
\leftline{\bf Errors}
Errors return 0, with no changes to the matrix. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Matrix (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Row index \%d (argument 2) is negative."}&12\\
\parbox[t]{5.in}{"Row index \%d (argument 2) is too large. Must be less than \%d"}&12\\
\parbox[t]{5.in}{"Column index \%d (argument 3) is negative".}&12\\
\parbox[t]{5.in}{"Column index \%d (argument 3) is too large. Must be less than \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNMaximize and LNMaximizeDLL}
\label{Subroutine:LNMaximize}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLLancelot data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=LNMaximize({\it Lan},{\it P},{\it x0},{\it z0},{\it l0},{\it x});}
\leftline{\tt {\it c}=LNMaximizeDLL({\it Lan},{\it P},{\it x0},{\it z0},{\it l0},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem to be solved.}\\
\tt double&*\it x0 &\parbox[t]{\SYNTAX}{The initial guess.}\\
\tt double&*\it z0 &\parbox[t]{\SYNTAX}{The initial value of the min-max variabls, or (double*)NULL.}\\
\tt double&*\it l0 &\parbox[t]{\SYNTAX}{The initial guess at the multipliers, or (double*)NULL.}\\
\tt double&*\it x &\parbox[t]{\SYNTAX}{The solution.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt LNMinimize} invokes Lancelot to find a maximizer
of the objective function of a problem. If there are
min-max constraints the vector containing the inital values 
for the minmax variables should be either NULL (no value), 
or one. The vector containing
the initial Lagrange multipliers should either be NULL (no
values given), or length as long as the total number of constraints,
including min-max constraints). 

Note: the user is responsible for allocating sufficient space for the 
solution.
\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Pointer to initial guess (argument 2) is NULL"}&12\\
\parbox[t]{5.in}{"Pointer to area to store the solution (argument 4) is NULL"}&12\\
\parbox[t]{5.in}{"Error opening file \%s for writing in current directory"}&12\\
\parbox[t]{5.in}{"Error closing file \%s"}&4\\
\parbox[t]{5.in}{"Error opening file SOLUTION.d for reading in current directory"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNMinimize}
\label{Subroutine:LNMinimize}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLLancelot data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=LNMinimize({\it Lan},{\it P},{\it x0},{\it z0},{\it l0},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem to be solved.}\\
\tt double&*\it x0 &\parbox[t]{\SYNTAX}{The initial guess.}\\
\tt double&*\it z0 &\parbox[t]{\SYNTAX}{The initial values of the min-max variables (currently only one value), or (double*)NULL.}\\
\tt double&*\it l0 &\parbox[t]{\SYNTAX}{The initial guess at the multipliers, or (double*)NULL.}\\
\tt double&*\it x &\parbox[t]{\SYNTAX}{The solution.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt LNMinimize} invokes Lancelot to find a minimizer
of the objective function of a problem. If there are
min-max constraints the vector containing the inital values 
for the minmax variables should be either NULL (no value), 
or one. The vector containing
the initial Lagrange multipliers should either be NULL (no
values given), or length as long as the total number of constraints,
including min-max constraints). 

Note: the user is responsible for allocating sufficient space for the 
solution.
\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Pointer to initial guess (argument 2) is NULL"}&12\\
\parbox[t]{5.in}{"Pointer to area to store the solution (argument 4) is NULL"}&12\\
\parbox[t]{5.in}{"Error opening file \%s for writing in current directory"}&12\\
\parbox[t]{5.in}{"Error closing file \%s"}&4\\
\parbox[t]{5.in}{"Error opening file SOLUTION.d for reading in current directory"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetElementDimension}
\label{Subroutine:NLNEGetElementDimension}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of element variables for a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLNEGetElementDimension({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of element variables.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of element variables for a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetElementFunction}
\label{Subroutine:NLNEGetElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLNEGetElementFunction({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction &\it f &\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the element function of a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetIndex}
\label{Subroutine:NLNEGetIndex}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of an element variable of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it var}=NLNEGetIndex({\it P},{\it ne},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it var &\parbox[t]{\SYNTAX}{The variable.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The index of the element variable.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of an element variable of a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Nonlinear Element (argument 2) is invalid"}&12\\
\parbox[t]{5.in}{"Variable (argument 3) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetInternalDimension}
\label{Subroutine:NLNEGetInternalDimension}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of internal variables for a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLNEGetInternalDimension({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of internal variables.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of internal variables for a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetName}
\label{Subroutine:NLNEGetName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLNEGetName({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt char *&\it name &\parbox[t]{\SYNTAX}{The name.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NNLEGetRangeXForm}
\label{Subroutine:NNLEGetRangeXForm}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the range transformation of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NNLEGetRangeXForm({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt LNRangeXForm &\it f &\parbox[t]{\SYNTAX}{The range transformation (NULL if the identity).}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the range transformation of a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddGroupToObjective}
\label{Subroutine:NLPAddGroupToObjective}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a group to the objective function.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddGroupToObjective({\it P},{\it name},{\it type});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\tt char&*\it type &\parbox[t]{\SYNTAX}{The type of the new group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a group to the objective function. The {\it name}
of the group must be unique. The {\it type} need not be.

A trivial group is added, with no nonlinear element, and a zero linear element.
This can be added with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddLinearEqualityConstraint}
\label{Subroutine:NLPAddLinearEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a linear equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddLinearEqualityConstraint({\it P},{\it name},{\it a},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\tt double&*\it a &\parbox[t]{\SYNTAX}{The linear part of the linear element.}\\
\tt double&\it b &\parbox[t]{\SYNTAX}{The constant part of the linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a 
linear equality constraint. That is, a constraint with the trivial group and
no nonlinear elements. This is a convenience routine, the same as invoking the
{{\tt NLPAddNonlinearEqualityConstraint} (page \pageref{Subroutine:NLPAddNonlinearEqualityConstraint}), 
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}), 
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.

The {\it name}
of the group must be unique. The {\it type} need not be.

A trivial group is added, with no nonlinear element, and the given linear element.
The constraint can be modified using the
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddLinearInequalityConstraint}
\label{Subroutine:NLPAddLinearInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a linear inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddLinearInequalityConstraint({\it P},{\it name},{\it a},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\tt double&*\it a &\parbox[t]{\SYNTAX}{The linear part of the linear element.}\\
\tt double&\it b &\parbox[t]{\SYNTAX}{The constant part of the linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a linear inequality constraint.
The {\it name} of the group must be unique.

A trivial group is added, with no nonlinear element, and the given linear element.
The constraint may be changed with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.
Bounds can (and should be) set with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintLowerBound}),
{\tt NLPSet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintUpperBound}),
and
{\tt NLPSet\-Inequality\-Constraint\-Bounds} (page \pageref{Subroutine:NLPSetInequalityConstraintBounds})
subroutines.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddMinMaxConstraint}
\label{Subroutine:NLPAddMinMaxConstraint}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a nonlinear inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddMinMaxConstraint({\it P},{\it name});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a min-max constraint.
The {\it name} of the group must be unique.

A trivial group is added, with no nonlinear element, and a zero linear element.
This information can be added with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.
Bounds can (and should be) set with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintLowerBound}),
{\tt NLPSet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintUpperBound}),
and
{\tt NLPSet\-Inequality\-Constraint\-Bounds} (page \pageref{Subroutine:NLPSetInequalityConstraintBounds})
subroutines.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearElementToGroup}
\label{Subroutine:NLPAddNonlinearElementToGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an empty nonlinear element to a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it e}=NLPAddNonlinearElementToGroup({\it P},{\it group},{\it type},{\it weight},{\it f},{\it variables},{\it xfrm});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it e&\parbox[t]{\SYNTAX}{The index of the new nonlinear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt char&*\it type &\parbox[t]{\SYNTAX}{The type of the new nonlinear element.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt NLElementFunction&\it f &\parbox[t]{\SYNTAX}{The element function or NULL.}\\
\tt int&\*it variables &\parbox[t]{\SYNTAX}{A list of the internal variables.}\\
\tt NLMatrix&\it xfrm &\parbox[t]{\SYNTAX}{The range transformation or NULL.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear element to a group. The group may be
either a nonlinear constraint or an objective group.

If the element function passed is {\tt (NLElementFunction)NULL}, it is not set.
If the range transformation passed is {\tt (NLMatrix)NULL}, it is not set.
If a range transformation is given, it must have as many columns as there are
internal variables, and as many rows as the element function has unknowns.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearElementToObjectiveGroup}
\label{Subroutine:NLPAddNonlinearElementToObjectiveGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an empty nonlinear element to a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it e}=NLPAddNonlinearElementToObjectiveGroup({\it P},{\it group},{\it type},{\it weight},{\it f},{\it variables},{\it xfrm});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it e&\parbox[t]{\SYNTAX}{The index of the new nonlinear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt char&*\it type &\parbox[t]{\SYNTAX}{The type of the new nonlinear element.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt NLElementFunction&\it f &\parbox[t]{\SYNTAX}{The element function or NULL.}\\
\tt int&\*it variables &\parbox[t]{\SYNTAX}{A list of the internal variables.}\\
\tt NLMatrix&\it xfrm &\parbox[t]{\SYNTAX}{The range transformation or NULL.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear element to a group in the objective.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearElementToEqualityConstraint}
\label{Subroutine:NLPAddNonlinearElementToEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an empty nonlinear element to an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it e}=NLPAddNonlinearElementToEqualityConstraint({\it P},{\it constraint},{\it weight},{\it ne},{\it variables},{\it xfrm});}
int NLPAddNonlinearElementToEqualityConstraint(NLProblem P,int constraint,double w,NLNonlinearElement E);
\vskip .1in
\begin{tabular}{lll}
\tt int&\it e&\parbox[t]{\SYNTAX}{The index of the new nonlinear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt NLNonlinearElement&\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear element to an equality constraint.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Constraint \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearElementToInequalityConstraint}
\label{Subroutine:NLPAddNonlinearElementToInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an empty nonlinear element to an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it e}=NLPAddNonlinearElementToInequalityConstraint({\it P},{\it constraint},{\it weight},{\it ne},{\it variables},{\it xfrm});}
int NLPAddNonlinearElementToInequalityConstraint(NLProblem P,int constraint,double w,NLNonlinearElement E);
\vskip .1in
\begin{tabular}{lll}
\tt int&\it e&\parbox[t]{\SYNTAX}{The index of the new nonlinear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt NLNonlinearElement&\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear element to an inequality constraint.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Constraint \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearElementToMinMaxConstraint}
\label{Subroutine:NLPAddNonlinearElementToMinMaxConstraint}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an empty nonlinear element to a minmax constraint.
(Requires the two step version of Lancelot.)
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it e}=NLPAddNonlinearElementToMinMaxConstraint({\it P},{\it constraint},{\it weight},{\it ne},{\it variables},{\it xfrm});}
int NLPAddNonlinearElementToMinMaxConstraint(NLProblem P,int constraint,double w,NLNonlinearElement E);
\vskip .1in
\begin{tabular}{lll}
\tt int&\it e&\parbox[t]{\SYNTAX}{The index of the new nonlinear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt NLNonlinearElement&\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear element to a minmax constraint.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Constraint \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearEqualityConstraint}
\label{Subroutine:NLPAddNonlinearEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a nonlinear equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddNonlinearEqualityConstraint({\it P},{\it name});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a 
nonlinear equality constraint.
The {\it name}
of the group must be unique. The {\it type} need not be.

A trivial group is added, with no nonlinear element, and a zero linear element.
This can be added with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearInequalityConstraint}
\label{Subroutine:NLPAddNonlinearInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a nonlinear inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddNonlinearInequalityConstraint({\it P},{\it name});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear inequality constraint.
The {\it name} of the group must be unique.

A trivial group is added, with no nonlinear element, and a zero linear element.
This information can be added with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.
Bounds can (and should be) set with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintLowerBound}),
{\tt NLPSet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintUpperBound}),
and
{\tt NLPSet\-Inequality\-Constraint\-Bounds} (page \pageref{Subroutine:NLPSetInequalityConstraintBounds})
subroutines.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementFunction}
\label{Subroutine:NLPGetElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the nonlinear element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLPGetElementFunction({\it P},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction&\it f&\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The index of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the nonlinear element function of an element. Note that a
global index is used, not the numebr of the element in a group. That method
is used by the {\tt NLPGet\-Element\-Function\-Of\-Group} (page 
\pageref{Subroutine:NLPGetElementFunctionOfGroup}) routine.\vskip .1in
\leftline{\bf Errors}
Errors return (NLElementFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementFunctionOfGroup}
\label{Subroutine:NLPGetElementFunctionOfGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the nonlinear element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLPGetElementFunction({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction&\it f&\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the nonlinear element function of an element of a 
group. Note that a global index may also be used, with the
{\tt NLPGet\-Element\-Function} (page \pageref{Subroutine:NLPGetElementFunction})
routine.\vskip .1in
\leftline{\bf Errors}
Errors return (NLElementFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementIndexIntoWhole}
\label{Subroutine:NLPGetElementIndexIntoWhole}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of internal variables of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it var}=NLPGetElementIndexIntoWhole({\it P},{\it group},{\it element},{\it int i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it var &\parbox[t]{\SYNTAX}{The index of the internal variable.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\tt int&\it i&\parbox[t]{\SYNTAX}{Which internal variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of an internal variable of a nonlinear element
in a group. The group may be either a nonlinear constraint or an objective 
group.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element Internal Variable index \%d is illegal (argument 4). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementNumberOfUnknowns}
\label{Subroutine:NLPGetElementNumberOfUnknowns}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of unknowns of a nonlinear element function.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetElementNumberOfUnknowns({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of unknowns.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of unknowns of a nonlinear element function
in a group.
The group may be either a nonlinear constraint or an objective group.

Note: this is not the number of internal variables of an element, since the 
range transformation may be applied before the element function is evaluated.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementRangeTransformation}
\label{Subroutine:NLPGetElementRangeTransformation}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the range transformation of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it xfrm}=NLPGetElementRangeTransformation({\it P},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it xfrm &\parbox[t]{\SYNTAX}{The range transformation.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The index of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the range transformation of a nonlinear element in a group.
 Note that a
global index is used, not the numebr of the element in a group. That method
is used by the {\tt NLPGet\-Element\-Range\-Transformation\-Of\-Group} (page
\pageref{Subroutine:NLPGetElementRangeTransformationOfGroup}) routine.
\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"The global element index \%d (argument 2) is illegal, must be in range 0 to \%d."}&4\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementRangeTransformationOfGroup}
\label{Subroutine:NLPGetElementRangeTransformationOfGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the range transformation of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLPGetElementRangeTransformationOfGroup({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt LNRangeTransformation&\it f&\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the range transformation of an element of a 
group. Note that a global index may also be used, with the
{\tt NLPGet\-Element\-Range\-Transformation} (page \pageref{Subroutine:NLPGetElementRangeTransformation})
routine.\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementType}
\label{Subroutine:NLPGetElementType}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of a type of nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it type}=NLPGetElementType({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it type &\parbox[t]{\SYNTAX}{The index of the element type.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which type.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of an element type. Element types are
assigned with the 
{\tt NLCreate\-Nonlinear\-Element} (page \pageref{Subroutine:NLCreateNonlinearElement}) 
subroutine. A new type name is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Element type \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementTypeName}
\label{Subroutine:NLPGetElementTypeName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the type name of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetElementTypeName({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The type name of the element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element &\parbox[t]{\SYNTAX}{The number of the element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the type name of a nonlinear element. Element types are
assigned with the 
{\tt NLCreate\-Nonlinear\-Element} (page \pageref{Subroutine:NLCreateNonlinearElement}) 
subroutine. A new type is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementWeight}
\label{Subroutine:NLPGetElementWeight}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the weight of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it weight}=NLPGetElementWeight({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the weight of a nonlinear element in a group. The group
may be either a nonlinear constraint or an objective group.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetEqualityConstraintGroupNumber}
\label{Subroutine:NLPGetEqualityConstraintGroupNumber}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of the group representing an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it group}=NLPGetEqualityConstraintGroupNumber({\it P},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it group&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of the group representing an equality constraint.
This is the same index that is returned by the 
{\tt NLPAdd\-Nonlinear\-Equality\-Constraint} (page \pageref{Subroutine:NLPAddNonlinearEqualityConstraint})
subroutine.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupA}
\label{Subroutine:NLPGetGroupA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the linear part of the linear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it a}=NLPGetGroupA({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of a group. This can
be queried with the {\tt NLPGet\-GroupA} (page \pageref{Subroutine:NLPGetGroupA})
subroutine. The default value is the zero vector.

The vector must have as many entires as the number of variables in the problem.
See the {\tt NLCreate\-Vector} (page \pageref{Subroutine:NLCreateVector}),
the {\tt NLCreate\-Vector\-With\-Full\-Data} (page 
\pageref{Subroutine:NLCreateVectorWithFullData}),
and the {\tt NLCreate\-Vector\-With\-Sparse\-Data} (page 
\pageref{Subroutine:NLCreateVectorWithSparseData}) subroutines.\vskip .1in
\leftline{\bf Errors}
Errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupB}
\label{Subroutine:NLPGetGroupB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the constant part of the linear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it b}=NLPGetGroupB({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the constant part of the lineear element of a group. This can
be queried with the {\tt NLPGet\-GroupB} (page \pageref{Subroutine:NLPGetGroupB})
subroutine.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupFunction}
\label{Subroutine:NLPGetGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the group function of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPGetGroupFunction({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt NLGroupFunction&\it g&\parbox[t]{\SYNTAX}{The group function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the group function of a group. This can be set with
the {\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction})
subroutine. The default value is the identity (the trivial group).\vskip .1in
\leftline{\bf Errors}
Errors return (NLGroupFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupName}
\label{Subroutine:NLPGetGroupName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetGroupName({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a group. Group names are assigned 
with the {\tt NLPAdd\-Group\-To\-Objective} (page \pageref{Subroutine:NLPAddGroupToObjective})
subroutine, as the second argument.
Group names need to be unique.

Note: The user should not free the returned string.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupNonlinearElement}
\label{Subroutine:NLPGetGroupNonlinearElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns a nonlinear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ne}=NLPGetGroupNonlinearElement({\it P},{\it group},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt NLNonlinearElement \it ne&\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt int {\it group}&\parbox[t]{\SYNTAX}{The group.}\\
\tt int {\it i}&\parbox[t]{\SYNTAX}{Which element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLPGetGroupNonlinearElement} returns a nonlinear element of a group.

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group (argument 2) is invalid"}&12\\
\parbox[t]{5.in}{"Element (argument 3) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupScale}
\label{Subroutine:NLPGetGroupScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the scale factor of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it s}=NLPGetGroupScale({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it s&\parbox[t]{\SYNTAX}{The scale factor.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the scale factor of a group. This can
be queried with the {\tt NLPGet\-Group\-Scale} (page \pageref{Subroutine:NLPGetGroupScale})
subroutine.

Note: The definition uses $1/s$ to multiply the group function.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupType}
\label{Subroutine:NLPGetGroupType}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of a type of group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it type}=NLPGetGroupType({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it type &\parbox[t]{\SYNTAX}{The type.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The index of the type.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of a group type. Group types are
assigned with the 
{\tt NLPAdd\-Group\-To\-Objective} (page \pageref{Subroutine:NLPAddGroupToObjective}) 
subroutine. A new type name is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Type \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupTypeName}
\label{Subroutine:NLPGetGroupTypeName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a type of group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetGroupTypeName({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the group type.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the group type.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a type of group. Group types are assigned 
with the {\tt NLPAdd\-Group\-To\-Objective} (page
\pageref{Subroutine:NLPAddGroupToObjective})
subroutine, as the last argument. A new
group is assigned a number, and the name is stored. The type name 
``TRIVIAL GROUP'' is always defined, and is type number 0.

Note: The user should not free the returned string.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetInequalityConstraintGroupNumber}
\label{Subroutine:NLPGetInequalityConstraintGroupNumber}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of the group representing an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it group}=NLPGetInequalityConstraintGroupNumber({\it P},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it group&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of the group representing an inequality constraint.
This is the same index that is returned by the 
{\tt NLPAdd\-Nonlinear\-Inequality\-Constraint} (page \pageref{Subroutine:NLPAddNonlinearInequalityConstraint})
subroutine.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetInequalityConstraintLowerBound}
\label{Subroutine:NLPGetInequalityConstraintLowerBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the lower bound for an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it l}=NLPGetInequalityConstraintLowerBound({\it P},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the lower bound for the inequality constraint.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetInequalityConstraintUpperBound}
\label{Subroutine:NLPGetInequalityConstraintUpperBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the upper bound for an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it u}=NLPGetInequalityConstraintUpperBound({\it P},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine gets the upper bound for an inequality constraint.

Initially the bound is $\infty$. (A value of $1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetLowerMinMaxBound}
\label{Subroutine:NLPSetLowerMinMaxBound}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the lower bound on the min-max variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetLowerMinMaxBound({\it P},{\it l});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the lower bound on the the min-max variable. This can
be queried with the 
{\tt NLPGet\-Lower\-MinMax\-Bound} (page \pageref{Subroutine:NLPGetLowerMinMaxBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-MinMax\-Bounds} (page \pageref{Subroutine:NLPSetMinMaxBounds})
routine.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetLowerSimpleBound}
\label{Subroutine:NLPGetLowerSimpleBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the lower bound on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it l}=NLPGetLowerSimpleBound({\it P},{\it var});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the lower bound on the variable.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetMinMaxConstraintGroupNumber}
\label{Subroutine:NLPGetMinMaxConstraintGroupNumber}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of the group representing a min-max constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it group}=NLPGetMinMaxConstraintGroupNumber({\it P},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it group&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of the group representing a min-max constraint.
This is the same index that is returned by the 
{\tt NLPAdd\-MinMax\-Constraint} (page \pageref{Subroutine:NLPAddMinMaxConstraint})
subroutine.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"MinMax constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementTypes}
\label{Subroutine:NLPGetNumberOfElementTypes}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of distinct types of nonlinear elements.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementTypes({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of element types.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of distinct element types. Element types are
assigned with the 
{\tt NLCreate\-Nonlinear\-Element} (page \pageref{Subroutine:NLCreateNonlinearElement}) 
subroutine. A new type name is assigned a number, and the 
name is stored.
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElements}
\label{Subroutine:NLPGetNumberOfElements}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements for a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElements({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements for a problem.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementsE}
\label{Subroutine:NLPGetNumberOfElementsE}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements in the equality constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementsE({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements in the equality 
constraints.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementsI}
\label{Subroutine:NLPGetNumberOfElementsI}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements in the inequality constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementsI({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements in the inequality
constraints.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementsInGroup}
\label{Subroutine:NLPGetNumberOfElementsInGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements in a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementsInGroup({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{Which group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements in a group.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementsM}
\label{Subroutine:NLPGetNumberOfElementsM}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements in the min-max constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementsM({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements in the min-max
constraints.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementsO}
\label{Subroutine:NLPGetNumberOfElementsO}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements in the Objective.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementsiO({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements in the Objective.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfEqualityConstraints}
\label{Subroutine:NLPGetNumberOfEqualityConstraints}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of equality constraints in a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfEqualityConstraints({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of constraints.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the current number of equality constraints in a problem.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfGroupTypes}
\label{Subroutine:NLPGetNumberOfGroupTypes}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of distinct types of groups.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfGroupTypes({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of group types.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of distinct group types. Group types are
assigned with the 
{\tt NLPAdd\-Group\-To\-Objective} (page \pageref{Subroutine:NLPAddGroupToObjective}) 
subroutine. A new type name is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfGroups}
\label{Subroutine:NLPGetNumberOfGroups}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of groups in a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfGroups({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of groups.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the current number of groups in a problem. Each time
a group is added to the objective, or a nonlinear constraint is added this
number increases. It never decreases.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfGroupsInObjective}
\label{Subroutine:NLPGetNumberOfGroupsInObjective}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of groups in the objective of a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfGroupsInObjective({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of groups.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the current number of groups in the objective of a 
problem. Each time a group is added to the objective this
number increases. It never decreases.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfInequalityConstraints}
\label{Subroutine:NLPGetNumberOfInequalityConstraints}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of inequality constraints in a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfInequalityConstraints({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of constraints.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the current number of inequality constraints in a problem.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfInternalVariablesInElement}
\label{Subroutine:NLPGetNumberOfInternalVariablesInElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of internal variables of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetElementNumberOfInternalVariablesInElement({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of internal variables.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of internal variables of a nonlinear element in a group.
The group may be either a nonlinear constraint or an objective group.

Note: this is not the number of unknowns of an element function, since the range
transformation may be applied before the element function is evaluated.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfMinMaxConstraints}
\label{Subroutine:NLPGetNumberOfMinMaxConstraints}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of equality constraints in a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfMinMaxConstraints({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of constraints.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the current number of min-max constraints in a problem.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfNonlinearElements}
\label{Subroutine:NLPGetNumberOfNonlinearElements}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of nonlinear elements.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfNonlinearElements({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it n&\parbox[t]{\SYNTAX}{The number of nonlinear elements.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLPGetNumberOfNonlinearElements} returns the number of nonlinear elements.

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfVariables}
\label{Subroutine:NLPGetNumberOfVariables}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of variables for a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfVariables({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of variables.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of variables for a problem. This is set when
the {\tt NLCreate\-Problem} (page \pageref{Subroutine:NLCreateProblem}) subroutine
is called.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetObjectiveGroupNumber}
\label{Subroutine:NLPGetObjectiveGroupNumber}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of a group in the objective of a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPGetObjectiveGroupNumber({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of a group in the objective of a 
problem. Group queries use the group index. This routine can be
used to query the properties of all of the groups in the Objective.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetProblemName}
\label{Subroutine:NLPGetProblemName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetProblemName({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The problem name.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a problem, which was passed to the
{\tt NLCreate\-Problem} (page \pageref{Subroutine:NLCreateProblem}) subroutine. 

Note: The user should not free the returned string.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetTypeOfElement}
\label{Subroutine:NLPGetTypeOfElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the type name of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it type}=NLPTypeOfElement({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it type &\parbox[t]{\SYNTAX}{The type of the element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element &\parbox[t]{\SYNTAX}{The number of the element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the type of a nonlinear element. Element types are
assigned with the 
{\tt NLCreate\-Nonlinear\-Element} (page \pageref{Subroutine:NLCreateNonlinearElement}) 
subroutine. A new type name is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetTypeOfGroup}
\label{Subroutine:NLPGetTypeOfGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the type of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it type}=NLPGetTypeOfGroup({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The type of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the group type.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the type of a group. Group types are assigned 
with the {\tt NLPAdd\-Group\-To\-Objective} (page
\pageref{Subroutine:NLPAddGroupToObjective})
subroutine, as the last argument. A new
group is assigned a number, and the name is stored. The type name 
``TRIVIAL GROUP'' is always defined, and is type number 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetUpperMinMaxBound}
\label{Subroutine:NLPSetUpperMinMaxBound}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the upper bound on the min-max variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetUpperMinMaxBound({\it P},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the upper bound on the min-max variable. This can
be queried with the 
{\tt NLPGet\-Upper\-MinMax\-Bound} (page \pageref{Subroutine:NLPGetUpperMinMaxBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-MinMax\-Bounds} (page \pageref{Subroutine:NLPSetMinMaxBounds})
routine.

Initially the bound is $\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetUpperSimpleBound}
\label{Subroutine:NLPGetUpperSimpleBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the upper bound on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it u}=NLPGetUpperSimpleBound({\it P},{\it var});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine gets the upper bound on the variable.

Initially the bound is $\infty$. (A value of $1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetVariableName}
\label{Subroutine:NLPGetVariableName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetVariableName({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The problem name.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a variable. If the variable has not yet 
been given a name, the default is ``Xxxxxxxx'', where 'x' is a hex 
digit 0-9A-F. This is create with the C-format ``X%7.7x''. 

Note: The user should not free the returned string.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12
\\
\end{tabular}
\newpage
\leftline{\bf NLPGetVariableScale}
\label{Subroutine:NLPGetVariableScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the scale factor of a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it s}=NLPGetVariableScale({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it s&\parbox[t]{\SYNTAX}{The scale factor.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the scale factor of a variable. This is set with
the {\tt NLPSet\-Variable\-Scale} (page \pageref{Subroutine:NLPSetVariableScale})
subroutine. The default value is 1.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12
\\
\end{tabular}
\newpage
\leftline{\bf NLPIsElementFunctionSet}
\label{Subroutine:NLPIsElementFunctionSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the weight of a nonlinear element has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsElementFunctionSet({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element &\parbox[t]{\SYNTAX}{The number of the element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether the element function of a nonlinear element of 
a group has been set.  If it has not the routine returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsElementWeightSet}
\label{Subroutine:NLPIsElementWeightSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the weight of a nonlinear element has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsElementWeightSet({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element &\parbox[t]{\SYNTAX}{The number of the element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether the weight of a nonlinear element of a group
has been set.  If it has not the routine returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsGroupASet}
\label{Subroutine:NLPIsGroupASet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the linear part of the linear element of a group has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsGroupASet({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether the linear part of the linear element of a group
has been set.  If it has it's default value, the zero vector, the routine
returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsGroupBSet}
\label{Subroutine:NLPIsGroupBSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the constant part of the linear element of a group has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsGroupBSet({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether the constant part of the linear element of a group
has been set.  If it has it's default value, zero, the routine
returns 0, otherwise 1.

Note: setting the constant part to 0 with {\tt NLPSet\-GroupB} will not result 
in an ``unset'' result.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsGroupFunctionSet}
\label{Subroutine:NLPIsGroupFunctionSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the group function of a group has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsGroupFunctionSet({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine queries the group function of a group. If it has it's default 
value, the trivial group, 0 is returned, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsLowerSimpleBoundSet}
\label{Subroutine:NLPIsLowerSimpleBoundSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether a lower bound has been set on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsLowerSimpleBoundSet({\it P},{\it var});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{The index of the variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether a lower bound has been set on a variable.
If it still has it's default value ($-\infty$), the routine
returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12
\\
\end{tabular}
\newpage
\leftline{\bf NLPIsUpperSimpleBoundSet}
\label{Subroutine:NLPIsUpperSimpleBoundSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether a upper bound has been set on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsUpperSimpleBoundSet({\it P},{\it var});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{The index of the variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether a upper bound has been set on a variable.
If it still has it's default value ($\infty$), the routine
returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12
\\
\end{tabular}
\newpage
\leftline{\bf NLPSetElementFunction}
\label{Subroutine:NLPSetElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Changes the nonlinear element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetElementFunction({\it P},{\it group},{\it element},{\it f},{\it variables});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\tt NLElementFunction&\it f &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int&\*it variables &\parbox[t]{\SYNTAX}{A list of the internal variables.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the nonlinear element function of an element of a group.
There must be as many entries in the list of internal variables as the
element function has unknowns.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetElementFunctionWithRange}
\label{Subroutine:NLPSetElementFunctionWithRange}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Changes the nonlinear element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetElementFunctionWithRange({\it P},{\it group},{\it element},{\it f},{\it variables},{\it xfrm});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\tt NLElementFunction&\it f &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int&\*it variables &\parbox[t]{\SYNTAX}{A list of the internal variables.}\\
\tt NLMatrix&\it xfrm &\parbox[t]{\SYNTAX}{The range transformation.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the nonlinear element function of an element of a group.
There must be as many entries in the list of internal variables as the
element function has unknowns.

The range transformation must have as many columns as there are
internal variables, and as many rows as the element function has unknowns.
\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes",n*sizeof(int)}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetElementWeight}
\label{Subroutine:NLPSetElementWeight}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Changes the weight of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetElementWeight({\it P},{\it group},{\it element},{\it weight});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the weight of a nonlinear element in a group. The group
may be either a nonlinear constraint or an objective group.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetEqualityConstraintA}
\label{Subroutine:NLPSetEqualityConstraintA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the linear part of the linear element of an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetEqualityConstraintA({\it P},{\it constraint},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of an equality constraint.
\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetEqualityConstraintB}
\label{Subroutine:NLPSetEqualityConstraintB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the constant part of the linear element of an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetEqualityConstraintB({\it P},{\it constraint},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the constant part of the linear element of an equality constraint.
The default value is zero.

Note: The definition uses a negative sign for the constant that might be counter
intuitive.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetGroupA}
\label{Subroutine:NLPSetGroupA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the linear part of the linear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetGroupA({\it P},{\it group},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of a group. This can
be queried with the {\tt NLPGet\-GroupA} (page \pageref{Subroutine:NLPGetGroupA})
subroutine.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetGroupB}
\label{Subroutine:NLPSetGroupB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the constant part of the linear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetGroupB({\it P},{\it group},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt double&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the constant part of the lineear element of a group. 
The default value is zero.

Note: The definition uses a negative sign for the constant that might be counter
intuitive.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetGroupFunction}
\label{Subroutine:NLPSetGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the group function of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetGroupFunction({\it P},{\it group},{\it g});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLGroupFunction&\it g&\parbox[t]{\SYNTAX}{The group function.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the group function of a group. This can be queried with
the {\tt NLPGet\-Group\-Function} (page \pageref{Subroutine:NLPGetGroupFunction})
subroutine. The default value is the identity (the trivial group).\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Can't Set Trivial Group's Group Function, group \%d",group}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetGroupScale}
\label{Subroutine:NLPSetGroupScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the scale factor of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetGroupScale({\it P},{\it group},{\it s});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt double&\it s&\parbox[t]{\SYNTAX}{The scale factor.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the scale factor of a group. This can
be queried with the {\tt NLPGet\-Group\-Scale} (page \pageref{Subroutine:NLPGetGroupScale})
subroutine.

Note: The definition uses $1/s$ to multiply the group function.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintA}
\label{Subroutine:NLPSetInequalityConstraintA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the linear part of the linear element of an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintA({\it P},{\it constraint},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of an inequality constraint.
\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintB}
\label{Subroutine:NLPSetInequalityConstraintB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the constant part of the linear element of an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintB({\it P},{\it constraint},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the constant part of the linear element of an inequality constraint.
The default value is zero.

Note: The definition uses a negative sign for the constant that might be counter
intuitive.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintBounds}
\label{Subroutine:NLPSetInequalityConstraintBounds}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the bounds on an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintBounds({\it P},{\it c},{\it l},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the bounds on the inequality constraint. This can
be queried with the 
{\tt NLPGet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPGetInequalityConstraintUpperBound})
and
{\tt NLPGet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPGetInequalityConstraintLowerBound})
subroutine. The bounds can also be set one at a time using the 
{\tt NLPSet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintUpperBound})
and
{\tt NLPSet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintLowerBound})
routines.

Initially the bounds are $-\infty$ to $\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.) Obviously this is no constraint at all unless the bounds are set.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintLowerBound}
\label{Subroutine:NLPSetInequalityConstraintLowerBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the lower bound on an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintLowerBound({\it P},{\it c},{\it l});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the lower bound on the inequality constraint. This can
be queried with the 
{\tt NLPGet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPGetInequalityConstraintLowerBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-Inequality\-Constraint\-Bounds} (page \pageref{Subroutine:NLPSetInequalityConstraintBounds})
routine.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintUpperBound}
\label{Subroutine:NLPSetInequalityConstraintUpperBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the upper bound on an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintUpperBound({\it P},{\it c},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the upper bound on the inequality constraint. This can
be queried with the 
{\tt NLPGet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPGetInequalityConstraintUpperBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-Inequality\-Constraint\-Bounds} (page \pageref{Subroutine:NLPSetInequalityConstraintBounds})
routine.

Initially the bound is $\infty$. (A value of $1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetLowerMinMaxBound}
\label{Subroutine:NLPGetLowerMinMaxBound}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the lower bound on the min-max variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it l}=NLPGetLowerMinMaxBound({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the lower bound on the min-max variable.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetLowerSimpleBound}
\label{Subroutine:NLPSetLowerSimpleBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the lower bound on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetLowerSimpleBound({\it P},{\it var},{\it l});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the lower bound on the variable. This can
be queried with the 
{\tt NLPGet\-Lower\-Simple\-Bound} (page \pageref{Subroutine:NLPGetLowerSimpleBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-Simple\-Bounds} (page \pageref{Subroutine:NLPSetSimpleBounds})
routine.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetMinMaxBounds}
\label{Subroutine:NLPSetMinMaxBounds}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the bounds on the min-max variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetMinMaxBounds({\it P},{\it l},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets both of the bounds on the min-max variable. These can
be queried with the 
{\tt NLPGet\-Upper\-MinMax\-Bound} (page \pageref{Subroutine:NLPGetUpperMinMaxBound})
and 
{\tt NLPGet\-Lower\-MinMax\-Bound} (page \pageref{Subroutine:NLPGetLowerMinMaxBound})
subroutines. The bounds can also be set one at a time using the 
{\tt NLPSet\-Lower\-MinMax\-Bound} (page \pageref{Subroutine:NLPSetLowerMinMaxBound})
and
{\tt NLPSet\-Upper\-MinMax\-Bound} (page \pageref{Subroutine:NLPSetUpperMinMaxBound})
routines.

Initially the bounds are infinite. A value of $1.e20$ is considered by Lancelot
to be infinity.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetMinMaxConstraintA}
\label{Subroutine:NLPSetMinMaxConstraintA}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the linear part of the linear element of an minmax constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetMinMaxConstraintA({\it P},{\it constraint},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of an minmax constraint.
\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetMinMaxConstraintB}
\label{Subroutine:NLPSetMinMaxConstraintB}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the constant part of the linear element of an minmax constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetMinMaxConstraintB({\it P},{\it constraint},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the constant part of the linear element of an minmax constraint.
The default value is zero.

Note: The definition uses a negative sign for the constant that might be counter
intuitive.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjectiveGroupA}
\label{Subroutine:NLPSetObjectiveGroupA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the linear part of the linear element of a group in the objective.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetObjectiveGroupA({\it P},{\it group},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of a group in the objective. 
\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjectiveGroupB}
\label{Subroutine:NLPSetObjectiveGroupB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the constant part of the linear element of a group in the objective.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetObjectiveGroupB({\it P},{\it group},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt double&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the constant part of the linear element of a group in the objective.
The default value is zero.

Note: The definition uses a negative sign for the constant that might be counter
intuitive.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjectiveGroupFunction}
\label{Subroutine:NLPSetObjectiveGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the group function of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetObjectiveGroupFunction({\it P},{\it group},{\it g});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLGroupFunction&\it g&\parbox[t]{\SYNTAX}{The group function.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the group function of a group in the objective.
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"Can't Set Trivial Group's Group Function, group \%d",group}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjectiveGroupScale}
\label{Subroutine:NLPSetObjectiveGroupScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the group function of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetObjectiveGroupScale({\it P},{\it group},{\it s});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt double&\it s&\parbox[t]{\SYNTAX}{The group scale factor.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the group scale of a group in the objective.
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetSimpleBounds}
\label{Subroutine:NLPSetSimpleBounds}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the bounds on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetSimpleBounds({\it P},{\it var},{\it l},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets both of the bounds on the variable. These can
be queried with the 
{\tt NLPGet\-Upper\-Simple\-Bound} (page \pageref{Subroutine:NLPGetUpperSimpleBound})
and 
{\tt NLPGet\-Lower\-Simple\-Bound} (page \pageref{Subroutine:NLPGetLowerSimpleBound})
subroutines. The bounds can also be set one at a time using the 
{\tt NLPSet\-Lower\-Simple\-Bound} (page \pageref{Subroutine:NLPSetLowerSimpleBound})
and
{\tt NLPSet\-Upper\-Simple\-Bound} (page \pageref{Subroutine:NLPSetUpperSimpleBound})
routines.

Initially the bounds are infinite. A value of $1.e20$ is considered by Lancelot
to be infinity.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetUpperMinMaxBound}
\label{Subroutine:NLPGetUpperMinMaxBound}
\vskip .5in

\leftline{\bf THIS IS AN EXTENSTION TO VANILLA LANCELOT}

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the upper bound on the min-max variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it u}=NLPGetUpperMinMaxBound({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine gets the upper bound on the min-max variable.

Initially the bound is $\infty$. (A value of $1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetUpperSimpleBound}
\label{Subroutine:NLPSetUpperSimpleBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the upper bound on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetUpperSimpleBound({\it P},{\it var},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the upper bound on the variable. This can
be queried with the 
{\tt NLPGet\-Upper\-Simple\-Bound} (page \pageref{Subroutine:NLPGetUpperSimpleBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-Simple\-Bounds} (page \pageref{Subroutine:NLPSetSimpleBounds})
routine.

Initially the bound is $\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetVariableName}
\label{Subroutine:NLPSetVariableName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Assigns the name of a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetVariableName({\it P},{\it i},{\it name});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the variable.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The problem name.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the name of a variable. This may be queried with the
{\tt NLPSet\-Variable\-Name} subroutine (page \pageref{Subroutine:NLPSetVariableName}).
If the variable has not yet 
been given a name, the default is ``Xxxxxxxx'', where 'x' is a hex 
digit 0-9A-F. This is create with the C-format ``X%7.7x''. 

A copy of the string is made. The copy is freed when the problem is freed.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\parbox[t]{5.in}{"The pointer to the variable name (argument 3) is NULL."}&4\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetVariableScale}
\label{Subroutine:NLPSetVariableScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the scale factor of a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetVariableScale({\it P},{\it i},{\it s});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The variable.}\\
\tt double&\it s&\parbox[t]{\SYNTAX}{The scale factor.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the scale factor of a variable. This can be queried with
the {\tt NLPGet\-Variable\-Scale} (page \pageref{Subroutine:NLPGetVariableScale})
subroutine. The default value is 1.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPrintProblem}
\label{Subroutine:NLPrintProblem}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Prints a NLProblem data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLPrintProblem({\it fid},{\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt FILE &*{\it fid}&\parbox[t]{\SYNTAX}{The output file.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLPrint\-Problem} prints an NLProblem data structure. The output attempts
to mimic the SIF decoders printing.\vskip .1in
\leftline{\bf Errors}
Errors return without printing the problem.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"File pointer (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Problem (argument 2) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefElementFunction}
\label{Subroutine:NLRefElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLElementFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefElementFunction({\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLElementFunction data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Element\-Function} subroutine (page \pageref{Subroutine:NLFreeElementFunction})
is used to delete the vector, and is only used once per added reference.
\vskip .1in
\leftline{\bf Errors}
Errors return without chaning the element function.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Element Function (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefGroupFunction}
\label{Subroutine:NLRefGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLGroupFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefGroupFunction({\it G});}
\vskip .1in
\begin{tabular}{lll}
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLGroupFunction data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Group\-Function} subroutine (page \pageref{Subroutine:NLFreeGroupFunction})
is used to delete the vector, and is only used once per added reference.
\vskip .1in
\leftline{\bf Errors}
Errors return without changing the group function.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Group Function (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefMatrix}
\label{Subroutine:NLRefMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLMatrix data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefMatrix({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLMatrix data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Matrix} subroutine (page \pageref{Subroutine:NLFreeMatrix})
is used to delete the vector, and is only used once per added reference.
\vskip .1in
\leftline{\bf Errors}
Error returns without changing the matrix.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Matrix (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLRefNonlinearElement}
\label{Subroutine:NLRefNonlinearElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLNonlinearElement data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefNonlinearElement({\it P},{\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLNonlinearElement data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Nonlinear\-Element} subroutine (page \pageref{Subroutine:NLFreeNonlinearElement})
is used to delete the vector, and is only used once per added reference.
\vskip .1in
\leftline{\bf Errors}
Errors return without chaning the element function.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Element Function (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefVector}
\label{Subroutine:NLRefVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLVector data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefVector({\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector &\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLVector data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Vector} subroutine (page \pageref{Subroutine:NLFreeVector})
is used to delete the vector, and is only used once per added reference.\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return without changing the vector.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf LNSetCheckDerivatives}
\label{Subroutine:LNSetCheckDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how Lancelot testtests derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetCheckDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it flag &\parbox[t]{\SYNTAX}{How to test.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Check\-Derivatives} 
sets the parameter controlling how Lancelot tests derivatives.
Legal values for the flag and their meaning --
\begin{center}
\begin{tabular}{ll}
0&No checking\\
1&Check all derivatives\\
2&Check derivatives\\
3&Check element derivatives\\
4&Check group derivatives\\
\end{tabular}
\end{center}
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Option \%d (argument 2) is invalid, must be in range 0-4"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetConstraintAccuracy}
\label{Subroutine:LNSetConstraintAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how accurately constraints are solved.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetConstraintAccuracy({\it Lan},{\it limit});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Constraint\-Accuracy} 
sets the parameter controlling how accurately the constraints are solved.
The default value is 0.00001.
The {\tt SPEC.SPC} file entry this corresponds to is {\tt CONSTRAINT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetFirstConstraintAccuracy}
\label{Subroutine:LNSetFirstConstraintAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the initial accuracy Lancelot uses for the constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetFirstConstraintAccuracy({\it Lan},{\it acc});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it acc &\parbox[t]{\SYNTAX}{The accuracy.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-First\-Constraint\-Accuracy} 
sets the parameter controlling the initial accuracy Lancelot uses for the constraints.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is {\tt FIRST-CONSTRAINT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetFirstGradientAccuracy}
\label{Subroutine:LNSetFirstGradientAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the initial accuracy for the gradients.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetFirstGradientAccuracy({\it Lan},{\it limit});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-First\-Gradient\-Accuracy} 
sets the parameter controlling the initial accuracy for the gradients.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is {\tt FIRST-GRADIENT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetGradientAccuracy}
\label{Subroutine:LNSetGradientAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the accuracy for the gradients.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetGradientAccuracy({\it Lan},{\it limit});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Gradient\-Accuracy} 
sets the parameter controlling the accuracy for the gradients.
The default value is 0.00001.
The {\tt SPEC.SPC} file entry this corresponds to is {\tt GRADIENT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetInitialPenalty}
\label{Subroutine:LNSetInitialPenalty}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the initial penalty.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetInitialPenalty({\it Lan},{\it penalty});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it penalty &\parbox[t]{\SYNTAX}{The penalty.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Initial\-Penalty} 
sets the parameter controlling the initial penalty.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is\hfill\break
{\tt INITIAL-PENALTY-PARAMETER}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetJiffyTuneTolerance}
\label{Subroutine:LNSetJiffyTuneTolerance}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the ``Jiffytune Tolerance''. {\bf NOTE:} this requires a modified version of Lancelot.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it value}=LNSetJiffyTuneTolerance({\it Lan},{\it value});}
\vskip .1in
\begin{tabular}{lll}
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it value &\parbox[t]{\SYNTAX}{Tolerance.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-JiffyTune\-Tolerance} 
sets the parameter controlling the ``Jiffytune Tolerance''.
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetLinearSolverMethod}
\label{Subroutine:LNSetLinearSolverMethod}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter determining what linear solver is used.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetLinearSolverMethod({\it Lan},{\it choice},{\it bandwidth});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt char&\it *choice &\parbox[t]{\SYNTAX}{}\\
\tt int&\it bandwidth &\parbox[t]{\SYNTAX}{Bandwidth, if choice is "bandsolver preconditioned"}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Linear\-Solver\-Method} 
sets the parameter determining what linear solver is used.

Legal values of {\it choice}, and the corresponding
{\tt SPEC.SPC} file entries are
\begin{center}
 \begin{tabular}{l}
  "Diagonal preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt DIAGONAL-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Munksgaards preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt MUNKSGAARDS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Expanding band preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt EXPANDING-BAND-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Full matrix preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt FULL-MATRIX-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Gill-Murray-Ponceleon-Saunders preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt GILL-MURRAY-PONCELEON-SAUNDERS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Modified MA27 preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt MODIFIED-MA27-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Schnabel-Eskow preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt SCHNABEL-ESKOW-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Users preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt USERS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Bandsolver preconditioned"\\
  \parbox[t]{5.in}{\hfill\tt BANDSOLVER-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Multifront"\\
  \parbox[t]{5.in}{\hfill\tt MULTIFRONT-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Direct modified"\\
  \parbox[t]{5.in}{\hfill\tt DIRECT-MODIFIED-MULTIFRONTAL-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "CG method used"\\
  \parbox[t]{5.in}{\hfill\tt CG-METHOD-USED}\\
 \end{tabular}
\end{center}\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{5.in}{"Linear Solver Type "\%s" (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetMaximumNumberOfIterations}
\label{Subroutine:LNSetMaximumNumberOfIterations}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how long Lancelot runs.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetMaximumNumberOfIterations({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{Maximum number of iterations.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Maximum\-Number\-Of\-Iterations} 
sets the parameter controlling how long Lancelot runs.
The default value is 100.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPenaltyBound}
\label{Subroutine:LNSetPenaltyBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the bound on the penalty Lancelot uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPenaltyBound({\it Lan},{\it penalty});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it penalty &\parbox[t]{\SYNTAX}{The bound.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Penalty\-Bound} 
sets the parameter controlling the bound on the penalty Lancelot uses.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is\hfill\break
{\tt DECREASE-PENALTY-PARAMETER-UNTIL}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPrintEvery}
\label{Subroutine:LNSetPrintEvery}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how often Lancelot prints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPrintEvery({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Print\-Every} 
sets the parameter controlling how often Lancelot prints.
The default value is 1.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPrintLevel}
\label{Subroutine:LNSetPrintLevel}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how much output Lancelot produces.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPrintLevel({\it Lan},{\it level});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it level &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Print\-Level} 
\noindent Sets the parameter controlling how Lancelot how much output Lancelot produces.
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"PrintLevel \%d (argument 2) is invalid, must be nonnegative"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPrintStart}
\label{Subroutine:LNSetPrintStart}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling when Lancelot starts printing.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPrintStart({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Print\-Start} 
sets the parameter controlling when Lancelot starts printing.
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPrintStop}
\label{Subroutine:LNSetPrintStop}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling when Lancelot stops printing.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPrintStop({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Print\-Stop} 
sets the parameter controlling when Lancelot stops printing.
The default value is 100.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetRequireExactCauchyPoint}
\label{Subroutine:LNSetRequireExactCauchyPoint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter determining whether an exact cauchy point is required.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetRequireExactCauchyPoint({\it Lan},{\it choice});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Require\-Exact\-Cauchy\-Point} 
sets the parameter determining whether an exact cauchy point is required.
The default is 1.

The corresponding {\tt SPEC.SPC} file entries are {\tt EXACT-CAUCHY-POINT-REQUIRED}
\hfill\break
and {\tt INEXACT-CAUCHY-POINT-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetSaveDataEvery}
\label{Subroutine:LNSetSaveDataEvery}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how often Lancelot saves data.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetSaveDataEvery({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Save\-Data\-Every} 
sets the parameter controlling how often Lancelot saves data.
The default value is 0 (don't save).\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetScalings}
\label{Subroutine:LNSetScalings}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how Lancelot uses scalings.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetScalings({\it Lan},{\it choice});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt char&*\it choice &\parbox[t]{\SYNTAX}{How to use scalings.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Scalings} 
sets the parameter controlling how Lancelot uses scalings.

The legal values for {\it choice} and the corresponding 
{\tt SPEC.SPC} file entries are
\begin{center}
\begin{tabular}{ll}
   "no scaling"&No entry in SPEC.SPC\\
   "scale constraints"&USE-CONSTRAINT-SCALING-FACTORS\\
   "scale variables"&USE-VARIABLE-SCALING-FACTORS\\
   "scale both"&USE-SCALING-FACTORS\\
   "print but don't use"&PRINT-SCALING-FACTORS\\
\end{tabular}
\end{center}\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{5.in}{"Scaling "\%s" (argument 2) is invalid, must be one of "No Scaling","Scale Constraints","Scale Variables","Scale Both","Print but don't use""}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetSolveBQPAccurately}
\label{Subroutine:LNSetSolveBQPAccurately}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the solution of the BQP.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetSolveBQPAccurately({\it Lan},{\it choice});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Solve\-BQP\-Accurately} 
sets the parameter controlling the solution of the BQP.
The default is 0.

The corresponding {\tt SPEC.SPC} file entry is {\tt SOLVE-BQP-ACCURATELY}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetStopOnBadDerivatives}
\label{Subroutine:LNSetStopOnBadDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how Lancelot deals with bad derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetStopOnBadDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Stop\-On\-Bad\-Derivatives} 
\noindent Sets the parameter controlling how Lancelot deals with bad derivatives.
Legal values for the flag and their meaning --
\begin{center}
\begin{tabular}{ll}
0&stop on warning\\
1&stop on element derivative warning\\
2&stop on group derivative warning\\
\end{tabular}
\end{center}
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Option \%d (argument 2) is invalid, must be in range 0-2"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetTrustRegionRadius}
\label{Subroutine:LNSetTrustRegionRadius}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the radius of the trust region.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetTrustRegionRadius({\it Lan},{\it radius});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it radius &\parbox[t]{\SYNTAX}{The radius.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Trust\-Region\-Radius} 
sets the parameter controlling the radius of the trust region.
The default value is 0.
The {\tt SPEC.SPC} file entry this sets is {\tt TRUST-REGION-RADIUS}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetTrustRegionType}
\label{Subroutine:LNSetTrustRegionType}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the type of trust region Lancelot uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetTrustRegionType({\it Lan},{\it choice});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt char&*\it choice &\parbox[t]{\SYNTAX}{Which type.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Trust\-Region\-Type} 
sets the parameter controlling the type of trust region Lancelot uses.
Legal values for the {\it choice} and their meaning --
\begin{center}
\begin{tabular}{lc}Message&Severity\\\hline
"two norm"&TWO-NORM-TRUST-REGION-USED\\
"infinity norm"&INFINITY-NORM-TRUST-REGION-USED\\
\end{tabular}
\end{center}
The default value is "infinity norm".\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{5.in}{"TrustRegionType "\%s" (argument 2) is invalid, must be one of "Two Norm" "Infinity Norm",choice}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetUseExactFirstDerivatives}
\label{Subroutine:LNSetUseExactFirstDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how Lancelot gets derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetUseExactFirstDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Use\-Exact\-First\-Derivatives} 
sets the parameter controlling how Lancelot gets derivatives. If
flag is 0, differencing is used, otherwise exact derivatives are 
expected.
The default value is 1 (exact derivatives). The {\tt SPEC.SPC} entry this
corresponds to is {\tt FINITE-DIFFERENCE-GRADIENTS}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetUseExactSecondDerivatives}
\label{Subroutine:LNSetUseExactSecondDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling second derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetUseExactSecondDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt char&\it *flag &\parbox[t]{\SYNTAX}{What to do - one of "Exact", "BFGS","DFP","PSB", or "SR1" }\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Use\-Exact\-Second\-Derivatives} 
sets the parameter controlling how second derivatives are handled. If
flag is 0, differencing is used, otherwise exact second derivatives are 
expected.
The default value is 1 (exact second derivatives). The {\tt SPEC.SPC} entry 
this corresponds to is {\tt EXACT-SECOND-DERIVATIVES-USED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{5.in}{"Option "\%s" is invalid, must be one of "Exact", "BFGS","DFP","PSB", "SR1","}&12\\
\end{tabular}
\newpage
\leftline{\bf NLVGetC}
\label{Subroutine:NLVGetC}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the dimension (the number of coordinates) of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLVGetC({\it v},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it c &\parbox[t]{\SYNTAX}{The value of the coordinate.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which coordinate to return.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of a coordinate of a 
vector. The index {\it i} must be nonnegative and less than the 
number of coordinates ({\tt LNVGet\-NC}).\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return a DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{5.in}{"Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVGetNC}
\label{Subroutine:NLVGetNC}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the dimension (the number of coordinates) of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLVGetNC({\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of non-zero coordinates.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the dimension, length or number of coordinates of a 
vector. This is set when the vector is created.
\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVGetNonZero}
\label{Subroutine:NLVGetNonZero}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the coordinate index of a non-zero coordinate in a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLVGetNonZero({\it v},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it c &\parbox[t]{\SYNTAX}{The value of the th non-zero coordinate.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which non-zero coordinate.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of a non-zero coordinate. The argument {\it i}
must be nonnegative and less than the number of non-zero coordinates 
{\tt LNVGetNumber of NonZeros}.\vskip .1in
\leftline{\bf Errors}
Errors return a DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{5.in}{"NonZero Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLVGetNonZeroCoord}
\label{Subroutine:NLVGetNonZeroCoord}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the coordinate index of a non-zero coordinate in a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLVGetNonZeroCoord({\it v},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The index of the non-zero coordinates.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which non-zero coordinate.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of a non-zero coordinate. The argument {\it i}
must be nonnegative and less than the number of non-zero coordinates 
{\tt LNVGetNumber of NonZeros}. The coordinate index {\it n} returned is 
nonnegative and less than the number of coordinates {\tt LNVGet\-NC}.\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{5.in}{"NonZero Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLVGetNumberOfNonZeros}
\label{Subroutine:NLVGetNumberOfNonZeros}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of non-zero coordinates in a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLVGetNumberOfNonZeros({\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of non-zero coordinates.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of non-zero coordinates in a vector. Note
that setting a coordinate to zero does not guarantee that the coordinate 
will be considered to be zero. It might be better to think of coordinates
that have been given values, and those that have not. Coordinates that
have not been given a value are defaulted to the value zero.\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVSetC}
\label{Subroutine:NLVSetC}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the specified coordinate of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLVSetC({\it v},{\it i},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which coordinate to return.}\\
\tt double&\it c &\parbox[t]{\SYNTAX}{The value of the coordinate.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the value of a coordinate of a 
vector. The index {\it i} must be nonnegative and less than the 
number of coordinates ({\tt LNVGet\-NC}). If the coordinate is not currently
set, it is added to the list of coordinates.\vskip .1in
\leftline{\bf Errors}
Errors return a 0, normal execution returns 1. Errors return without changing the vector.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{5.in}{"Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&4\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLVIncrementC}
\label{Subroutine:NLVIncrementC}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Increments the specified coordinate of coordinates) of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLVIncrementC({\it v},{\it i},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which coordinate to return.}\\
\tt double&\it c &\parbox[t]{\SYNTAX}{The amount to increment the coordinate.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the value of a coordinate of a 
vector. The index {\it i} must be nonnegative and less than the 
number of coordinates ({\tt LNVGet\-NC}). If the coordinate is not currently
set, it is added to the list of coordinates.\vskip .1in
\leftline{\bf Errors}
Errors return a 0, normal execution returns 1. Errors return without changing the vector.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{5.in}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{5.in}{"Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&4\\
\parbox[t]{5.in}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetMajorIterationCount}
\label{Subroutine:LNGetMajorIterationCount}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the current major iteration count. NOTE: this requires a 
modified version of Lancelot. Without that modification the count will always
be zero.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt \#include <fortran.h>}
\leftline{\tt {\it count}=F77NAME(LNGetMajorIterationCount)();}
\vskip .1in
\begin{tabular}{lll}
\tt F77INTEGER&\it count &\parbox[t]{\SYNTAX}{The major iteration count.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Major\-Iteration\-Count} returns the count of the 
current major iteration. It get this count from a common block added to 
Lancelot by Andy Conn on Dec. 7, 2000. Users with vanilla Lancelot will
always receive the same count, which will be whatever the common block is
initialized with.
\newpage
\leftline{\bf NLPEvaluateObjective, NLPEvaluateGradientOfObjective, NLPEvaluateHessianOfObjective}
\label{Subroutine:NLPEvaluateObjective}
\label{Subroutine:NLPEvaluateGradientOfObjective}
\label{Subroutine:NLPEvaluateHessianOfObjective}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Return the value of the objective and its derivatives at the given point.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it o}=NLPEvaluateObjective({\it P},{\it x});}
\leftline{\tt NLPEvaluateGradientOfObjective({\it P},{\it x},{\it g});}
\leftline{\tt NLPEvaluateHessianOfObjective({\it P},{\it x},{\it H});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it o&\parbox[t]{\SYNTAX}{The value of the objective function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLVector&\it x &\parbox[t]{\SYNTAX}{The point.}\\
\tt NLVector&\it g &\parbox[t]{\SYNTAX}{The gradient.}\\
\tt NLMatrix&\it H &\parbox[t]{\SYNTAX}{The Hessian.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
These routines are for evaluating the objective, its gradient and Hessian. The values of the elements and groups
are cached, and currently a new point is signaled by the routine {\tt NLPInvalidateGroupAndElementCaches}.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"X (argument 2) is NULL"}&12\\
\parbox[t]{5.in}{"g (argument 3) is NULL"}&12\\
\parbox[t]{5.in}{"H (argument 3) is NULL"}&12\\
\end{tabular}

\newpage
\leftline{\bf NLPEvaluateEqualityConstraint, NLPEvaluateGradientOfEqualityConstraint, NLPEvaluateHessianOfEqualityConstraint}
\label{Subroutine:NLPEvaluateEqualityConstraint}
\label{Subroutine:NLPEvaluateGradientOfEqualityConstraint}
\label{Subroutine:NLPEvaluateHessianOfEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Return the value of the objective and its derivatives at the given point.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLPEvaluateEqualityConstraint({\it P},{\it x});}
\leftline{\tt NLPEvaluateGradientOfEqualityConstraint({\it P},{\it x},{\it g});}
\leftline{\tt NLPEvaluateHessianOfEqualityConstraint({\it P},{\it x},{\it H});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it v&\parbox[t]{\SYNTAX}{The value of the objective function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLVector&\it x &\parbox[t]{\SYNTAX}{The point.}\\
\tt NLVector&\it g &\parbox[t]{\SYNTAX}{The gradient.}\\
\tt NLMatrix&\it H &\parbox[t]{\SYNTAX}{The Hessian.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
These routines are for evaluating the objective, its gradient and Hessian. The values of the elements and groups
are cached, and currently a new point is signaled by the routine {\tt NLPInvalidateGroupAndElementCaches}.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"X (argument 2) is NULL"}&12\\
\parbox[t]{5.in}{"g (argument 3) is NULL"}&12\\
\parbox[t]{5.in}{"H (argument 3) is NULL"}&12\\
\end{tabular}

\newpage
\leftline{\bf NLPEvaluateInequalityConstraint, NLPEvaluateGradientOfInequalityConstraint, NLPEvaluateHessianOfInequalityConstraint}
\label{Subroutine:NLPEvaluateInequalityConstraint}
\label{Subroutine:NLPEvaluateGradientOfInequalityConstraint}
\label{Subroutine:NLPEvaluateHessianOfInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Return the value of the objective and its derivatives at the given point.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLPEvaluateInequalityConstraint({\it P},{\it x});}
\leftline{\tt NLPEvaluateGradientOfInequalityConstraint({\it P},{\it x},{\it g});}
\leftline{\tt NLPEvaluateHessianOfInequalityConstraint({\it P},{\it x},{\it H});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it v&\parbox[t]{\SYNTAX}{The value of the objective function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLVector&\it x &\parbox[t]{\SYNTAX}{The point.}\\
\tt NLVector&\it g &\parbox[t]{\SYNTAX}{The gradient.}\\
\tt NLMatrix&\it H &\parbox[t]{\SYNTAX}{The Hessian.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
These routines are for evaluating the objective, its gradient and Hessian. The values of the elements and groups
are cached, and currently a new point is signaled by the routine {\tt NLPInvalidateGroupAndElementCaches}.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"X (argument 2) is NULL"}&12\\
\parbox[t]{5.in}{"g (argument 3) is NULL"}&12\\
\parbox[t]{5.in}{"H (argument 3) is NULL"}&12\\
\end{tabular}

\newpage
\leftline{\bf NLPEvaluateMinMaxConstraint, NLPEvaluateGradientOfMinMaxConstraint, NLPEvaluateHessianOfMinMaxConstraint}
\label{Subroutine:NLPEvaluateMinMaxConstraint}
\label{Subroutine:NLPEvaluateGradientOfMinMaxConstraint}
\label{Subroutine:NLPEvaluateHessianOfMinMaxConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Return the value of the objective and its derivatives at the given point.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLPEvaluateMinMaxConstraint({\it P},{\it x});}
\leftline{\tt NLPEvaluateGradientOfMinMaxConstraint({\it P},{\it x},{\it g});}
\leftline{\tt NLPEvaluateHessianOfMinMaxConstraint({\it P},{\it x},{\it H});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it v&\parbox[t]{\SYNTAX}{The value of the objective function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLVector&\it x &\parbox[t]{\SYNTAX}{The point.}\\
\tt NLVector&\it g &\parbox[t]{\SYNTAX}{The gradient.}\\
\tt NLMatrix&\it H &\parbox[t]{\SYNTAX}{The Hessian.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
These routines are for evaluating the objective, its gradient and Hessian. The values of the elements and groups
are cached, and currently a new point is signaled by the routine {\tt NLPInvalidateGroupAndElementCaches}.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{5.in}{"X (argument 2) is NULL"}&12\\
\parbox[t]{5.in}{"g (argument 3) is NULL"}&12\\
\parbox[t]{5.in}{"H (argument 3) is NULL"}&12\\
\end{tabular}

\newpage
\leftline{\bf NLPInvalidateGroupAndElementCaches}
\label{Subroutine:NLPInvalidateGroupAndElementCaches}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Marks the cahced values for the element and group functions as invalid.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLPInvalidateGroupAndElementCaches({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine signals that the stored values for the element and group functions need to be recomputed.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{5.in}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
