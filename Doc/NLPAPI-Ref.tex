\documentclass[12pt]{article}
\usepackage{graphics}

\def\R{\hbox{\rm I\kern-.2150em R}}
\def\B{\hbox{\rm I\kern-.2150em B}}
\def\maps{:}
\def\into{\rightarrow}
\def\QED{\vrule height 6 pt width 5 pt depth 0pt}
\def\nopageref#1{}
\def\SYNTAX{3.5in}
\def\ERRORMSG{4.5in}

\newtheorem{Definition}{Definition}
\newtheorem{Lemma}{Lemma}
\newtheorem{Task}[Definition]{Task}
\newtheorem{Corollary}[Lemma]{Corollary}
\newtheorem{Conjecture}[Lemma]{Conjecture}

\title{NLPAPI: An API to Nonlinear Programming Problems. {\bf Reference}}
\author{
  Michael E. Henderson\\[.5\baselineskip]
  IBM Research Division\\
  T. J. Watson Research Center\\
  Yorktown Heights, NY ~10598\\
  {\tt mhender@watson.ibm.com}
 }

\begin{document}

  \maketitle

\section{Contents}

\begin{center}
\begin{tabular}{ll}
\tt NLCreateProblem&\pageref{Subroutine:NLCreateProblem}\\
\tt NLRefProblem&\pageref{Subroutine:NLRefProblem}\\
\tt NLFreeProblem&\pageref{Subroutine:NLFreeProblem}\\
\\
\tt NLPrintProblem&\pageref{Subroutine:NLPrintProblem}\\
\tt NLPrintProblemShort&\pageref{Subroutine:NLPrintProblemShort}\\
\\
\tt NLPGetProblemName&\pageref{Subroutine:NLPGetProblemName}\\
\tt NLPGetNumberOfVariables&\pageref{Subroutine:NLPGetNumberOfVariables}\\
\tt NLPSetVariableScale&\pageref{Subroutine:NLPSetVariableScale}\\
\tt NLPGetVariableScale&\pageref{Subroutine:NLPGetVariableScale}\\
\tt NLPSetVariableName&\pageref{Subroutine:NLPSetVariableName}\\
\tt NLPGetVariableName&\pageref{Subroutine:NLPGetVariableName}\\
\tt NLPSetSimpleBounds&\pageref{Subroutine:NLPSetSimpleBounds}\\
\tt NLPSetLowerSimpleBound&\pageref{Subroutine:NLPSetLowerSimpleBound}\\
\tt NLPGetLowerSimpleBound&\pageref{Subroutine:NLPGetLowerSimpleBound}\\
\tt NLPIsLowerSimpleBoundSet&\pageref{Subroutine:NLPIsLowerSimpleBoundSet}\\
\tt NLPSetUpperSimpleBound&\pageref{Subroutine:NLPSetUpperSimpleBound}\\
\tt NLPGetUpperSimpleBound&\pageref{Subroutine:NLPGetUpperSimpleBound}\\
\tt NLPIsUpperSimpleBoundSet&\pageref{Subroutine:NLPIsUpperSimpleBoundSet}\\
\\
\tt NLConvertToEqualityAndBoundsOnly&\pageref{Subroutine:NLConvertToEqualityAndBoundsOnly}\\
\tt NLCopyProblem&\pageref{Subroutine:NLCopyProblem}\\
\tt NLCreateAugmentedLagrangian&\pageref{Subroutine:NLCreateAugmentedLagrangian}\\
\tt NLSetLambdaAndMuInAugmentedLagrangian&\pageref{Subroutine:NLSetLambdaAndMuInAugmentedLagrangian}\\
\tt NLEliminateFixedVariables&\pageref{Subroutine:NLEliminateFixedVariables}\\
\end{tabular}
\end{center}
\newpage

\subsubsection{The Objective}

\begin{center}
\begin{tabular}{ll}
\tt NLPSetObjective&\pageref{Subroutine:NLPSetObjective}\\
\tt NLPSetObjectiveByString&\pageref{Subroutine:NLPSetObjectiveByString}\\
\\
\tt NLPAddGroupToObjective&\pageref{Subroutine:NLPAddGroupToObjective}\\
\tt NLPAddNonlinearElementToObjectiveGroup&\pageref{Subroutine:NLPAddNonlinearElementToObjectiveGroup}\\
\tt NLPSetObjectiveGroupA&\pageref{Subroutine:NLPSetObjectiveGroupA}\\
\tt NLPSetObjectiveGroupB&\pageref{Subroutine:NLPSetObjectiveGroupB}\\
\tt NLPSetObjectiveGroupFunction&\pageref{Subroutine:NLPSetObjectiveGroupFunction}\\
\tt NLPSetObjectiveGroupScale&\pageref{Subroutine:NLPSetObjectiveGroupScale}\\
\\
\tt NLPGetNumberOfGroupsInObjective&\pageref{Subroutine:NLPGetNumberOfGroupsInObjective}\\
\tt NLPGetObjectiveGroupNumber&\pageref{Subroutine:NLPGetObjectiveGroupNumber}\\
\\
\tt NLPEvaluateObjective&\pageref{Subroutine:NLPEvaluateObjective}\\
\tt NLPEvaluateGradientOfObjective&\pageref{Subroutine:NLPEvaluateGradientOfObjective}\\
\tt NLPEvaluateHessianOfObjective&\pageref{Subroutine:NLPEvaluateHessianOfObjective}\\
\end{tabular}
\end{center}

\subsubsection{Equality Constraints}
\begin{center}
\begin{tabular}{ll}
\tt NLPAddEqualityConstraint&\pageref{Subroutine:NLPAddEqualityConstraint}\\
\tt NLPAddEqualityConstraintByString&\pageref{Subroutine:NLPAddEqualityConstraintByString}\\
\\
\tt NLPAddNonlinearEqualityConstraint&\pageref{Subroutine:NLPAddNonlinearEqualityConstraint}\\
\tt NLPAddLinearEqualityConstraint&\pageref{Subroutine:NLPAddLinearEqualityConstraint}\\
\\
\tt NLPAddNonlinearElementToEqualityConstraint&\pageref{Subroutine:NLPAddNonlinearElementToEqualityConstraint}\\
\tt NLPSetEqualityConstraintA&\pageref{Subroutine:NLPSetEqualityConstraintA}\\
\tt NLPSetEqualityConstraintB&\pageref{Subroutine:NLPSetEqualityConstraintB}\\
\\
\tt NLPGetNumberOfEqualityConstraints&\pageref{Subroutine:NLPGetNumberOfEqualityConstraints}\\
\tt NLPGetEqualityConstraintGroupNumber&\pageref{Subroutine:NLPGetEqualityConstraintGroupNumber}\\
\\
\tt NLPEvaluateEqualityConstraint&\pageref{Subroutine:NLPEvaluateEqualityConstraint}\\
\tt NLPEvaluateGradientOfEqualityConstraint&\pageref{Subroutine:NLPEvaluateGradientOfEqualityConstraint}\\
\tt NLPEvaluateHessianOfEqualityConstraint&\pageref{Subroutine:NLPEvaluateHessianOfEqualityConstraint}\\
\end{tabular}
\end{center}

\subsubsection{Inequality Constraints}
\begin{center}
\begin{tabular}{ll}
\tt NLPAddInequalityConstraint&\pageref{Subroutine:NLPAddInequalityConstraint}\\
\tt NLPAddInequalityConstraintByString&\pageref{Subroutine:NLPAddInequalityConstraintByString}\\
\\
\tt NLPAddNonlinearInequalityConstraint&\pageref{Subroutine:NLPAddNonlinearInequalityConstraint}\\
\tt NLPAddLinearInequalityConstraint&\pageref{Subroutine:NLPAddLinearInequalityConstraint}\\
\\
\tt NLPAddNonlinearElementToInequalityConstraint&\pageref{Subroutine:NLPAddNonlinearElementToInequalityConstraint}\\
\tt NLPSetInequalityConstraintA&\pageref{Subroutine:NLPSetInequalityConstraintA}\\
\tt NLPSetInequalityConstraintB&\pageref{Subroutine:NLPSetInequalityConstraintB}\\
\tt NLPGetInequalityConstraintLowerBound&\pageref{Subroutine:NLPGetInequalityConstraintLowerBound}\\
\tt NLPSetInequalityConstraintLowerBound&\pageref{Subroutine:NLPSetInequalityConstraintLowerBound}\\
\tt NLPGetInequalityConstraintUpperBound&\pageref{Subroutine:NLPGetInequalityConstraintUpperBound}\\
\tt NLPSetInequalityConstraintUpperBound&\pageref{Subroutine:NLPSetInequalityConstraintUpperBound}\\
\tt NLPSetInequalityConstraintBounds&\pageref{Subroutine:NLPSetInequalityConstraintBounds}\\
\\
\tt NLPGetNumberOfInequalityConstraints&\pageref{Subroutine:NLPGetNumberOfInequalityConstraints}\\
\tt NLPGetInequalityConstraintGroupNumber&\pageref{Subroutine:NLPGetInequalityConstraintGroupNumber}\\
\\
\tt NLPEvaluateInequalityConstraint&\pageref{Subroutine:NLPEvaluateInequalityConstraint}\\
\tt NLPEvaluateGradientOfInequalityConstraint&\pageref{Subroutine:NLPEvaluateGradientOfInequalityConstraint}\\
\tt NLPEvaluateHessianOfInequalityConstraint&\pageref{Subroutine:NLPEvaluateHessianOfInequalityConstraint}\\
\end{tabular}
\end{center}

\subsection{Error Handling}

\begin{center}
\begin{tabular}{ll}
\tt NLError&\pageref{Subroutine:NLError}\\
\tt NLGetNErrors&\pageref{Subroutine:NLGetNErrors}\\
\tt NLGetErrorSev&\pageref{Subroutine:NLGetErrorSev}\\
\tt NLGetErrorRoutine&\pageref{Subroutine:NLGetErrorRoutine}\\
\tt NLGetErrorMsg&\pageref{Subroutine:NLGetErrorMsg}\\
\tt NLGetErrorLine&\pageref{Subroutine:NLGetErrorLine}\\
\tt NLGetErrorFile&\pageref{Subroutine:NLGetErrorFile}\\
\tt NLClearErrors&\pageref{Subroutine:NLClearErrors}\\
\end{tabular}
\end{center}

\subsection{Vectors}

\begin{center}
\begin{tabular}{ll}
\tt NLCreateVector&\pageref{Subroutine:NLCreateVector}\\
\tt NLCreateVectorWithSparseData&\pageref{Subroutine:NLCreateVectorWithSparseData}\\
\tt NLCreateVectorWithFullData&\pageref{Subroutine:NLCreateVectorWithFullData}\\
\tt NLCreateDenseWrappedVector&\pageref{Subroutine:NLCreateDenseWrappedVector}\\
\\
\tt NLFreeVector&\pageref{Subroutine:NLFreeVector}\\
\tt NLRefVector&\pageref{Subroutine:NLRefVector}\\
\\
\tt NLPrintVector&\pageref{Subroutine:NLPrintVector}\\
\\
\tt NLVGetNC&\pageref{Subroutine:NLVGetNC}\\
\tt NLVGetC&\pageref{Subroutine:NLVGetC}\\
\tt NLVSetC&\pageref{Subroutine:NLVSetC}\\
\\
\tt NLCopyVector&\pageref{Subroutine:NLCopyVector}\\
\tt NLVSetToZero&\pageref{Subroutine:NLVSetToZero}\\
\tt NLVIncrementC&\pageref{Subroutine:NLVIncrementC}\\
\tt NLVInnerProd&\pageref{Subroutine:NLVInnerProd}\\
\tt NLVPlusV&\pageref{Subroutine:NLVPlusV}\\
\tt NLNegateVector&\pageref{Subroutine:NLNegateVector}\\
\\
\tt NLVSparse&\pageref{Subroutine:NLVSparse}\\
\tt NLVnNonZeros&\pageref{Subroutine:NLVnNonZeros}\\
\tt NLVnonZero&\pageref{Subroutine:NLVnonZero}\\
\tt NLVGetNumberOfNonZeros&\pageref{Subroutine:NLVGetNumberOfNonZeros}\\
\tt NLVGetNonZeroCoord&\pageref{Subroutine:NLVGetNonZeroCoord}\\
\tt NLVGetNonZero&\pageref{Subroutine:NLVGetNonZero}\\
\\
\tt NLVWrapped&\pageref{Subroutine:NLVWrapped}\\
\tt NLVData&\pageref{Subroutine:NLVData}\\
\end{tabular}
\end{center}

\subsection{Matrices}

\begin{center}
\begin{tabular}{ll}

\tt NLCreateMatrix&\pageref{Subroutine:NLCreateMatrix}\\
\tt NLCreateMatrixWithData&\pageref{Subroutine:NLCreateMatrixWithData}\\
\tt NLCreateSparseMatrix&\pageref{Subroutine:NLCreateSparseMatrix}\\
\tt NLCreateWSMPSparseMatrix&\pageref{Subroutine:NLCreateWSMPSparseMatrix}\\
\tt NLCreateDenseWrappedMatrix&\pageref{Subroutine:NLCreateDenseWrappedMatrix}\\
\\
\tt NLRefMatrix&\pageref{Subroutine:NLRefMatrix}\\
\tt NLFreeMatrix&\pageref{Subroutine:NLFreeMatrix}\\
\\
\tt NLMGetNumberOfRows&\pageref{Subroutine:NLMGetNumberOfRows}\\
\tt NLMGetNumberOfCols&\pageref{Subroutine:NLMGetNumberOfCols}\\
\tt NLMGetElement&\pageref{Subroutine:NLMGetElement}\\
\tt NLMSetElement&\pageref{Subroutine:NLMSetElement}\\
\tt NLMIncrementElement&\pageref{Subroutine:NLMIncrementElement}\\
\tt NLMatrixDoubleProduct&\pageref{Subroutine:NLMatrixDoubleProduct}\\
\tt NLMVMult&\pageref{Subroutine:NLMVMult}\\
\tt NLMVMultT&\pageref{Subroutine:NLMVMultT}\\
\tt NLMSetToZero&\pageref{Subroutine:NLMSetToZero}\\
\tt NLMatrixClone&\pageref{Subroutine:NLMatrixClone}\\
\tt NLGetGershgorinBounds&\pageref{Subroutine:NLGetGershgorinBounds}\\
\tt NLMatrixOneNorm&\pageref{Subroutine:NLMatrixOneNorm}\\
\tt NLMSumSubMatrixInto&\pageref{Subroutine:NLMSumSubMatrixInto}\\
\tt NLMSumRankOneInto&\pageref{Subroutine:NLMSumRankOneInto}\\
\tt NLMMMMProd&\pageref{Subroutine:NLMMMMProd}\\
\\
\tt NLMSparse&\pageref{Subroutine:NLMSparse}\\
\tt NLMDetermineHessianSparsityStructure&\pageref{Subroutine:NLMDetermineHessianSparsityStructure}\\
\tt NLMData&\pageref{Subroutine:NLMData}\\
\tt NLMnE&\pageref{Subroutine:NLMnE}\\
\tt NLMRow&\pageref{Subroutine:NLMRow}\\
\tt NLMCol&\pageref{Subroutine:NLMCol}\\
\\
\tt NLPrintMatrix&\pageref{Subroutine:NLPrintMatrix}\\
\end{tabular}
\end{center}

\subsection{Group Functions}

\begin{center}
\begin{tabular}{ll}
\tt NLCreateGroupFunctionByString&\pageref{Subroutine:NLCreateGroupFunctionByString}\\
\tt NLCreateGroupFunction&\pageref{Subroutine:NLCreateGroupFunction}\\
\tt NLRefGroupFunction&\pageref{Subroutine:NLRefGroupFunction}\\
\tt NLFreeGroupFunction&\pageref{Subroutine:NLFreeGroupFunction}\\
\\
\tt NLGEval&\pageref{Subroutine:NLGEval}\\
\tt NLGEvalDer&\pageref{Subroutine:NLGEvalDer}\\
\tt NLGEvalSecDer&\pageref{Subroutine:NLGEvalSecDer}\\
\end{tabular}
\end{center}

\subsection{Element Functions}

\begin{center}
\begin{tabular}{ll}
\tt NLCreateElementFunctionByString&\pageref{Subroutine:NLCreateElementFunctionByString}\\
\tt NLCreateElementFunction&\pageref{Subroutine:NLCreateElementFunction}\\
\tt NLRefElementFunction&\pageref{Subroutine:NLRefElementFunction}\\
\tt NLFreeElementFunction&\pageref{Subroutine:NLFreeElementFunction}\\
\\
\tt NLEGetDimension&\pageref{Subroutine:NLEGetDimension}\\
\tt NLEEval&\pageref{Subroutine:NLEEval}\\
\tt NLEEvalDer&\pageref{Subroutine:NLEEvalDer}\\
\tt NLEEvalSecDer&\pageref{Subroutine:NLEEvalSecDer}\\
\end{tabular}
\end{center}

\subsubsection{Nonlinear Elements}

\begin{center}
\begin{tabular}{ll}
\tt NLCreateNonlinearElement&\pageref{Subroutine:NLCreateNonlinearElement}\\
\tt NLRefNonlinearElement&\pageref{Subroutine:NLRefNonlinearElement}\\
\tt NLFreeNonlinearElement&\pageref{Subroutine:NLFreeNonlinearElement}\\
\\
\tt NLNEGetName&\pageref{Subroutine:NLNEGetName}\\
\tt NLNEGetElementDimension&\pageref{Subroutine:NLNEGetElementDimension}\\
\tt NLNEGetInternalDimension&\pageref{Subroutine:NLNEGetInternalDimension}\\
\tt NLNEGetElementFunction&\pageref{Subroutine:NLNEGetElementFunction}\\
\tt NLNEGetIndex&\pageref{Subroutine:NLNEGetIndex}\\
\tt NLNEGetRangeXForm&\pageref{Subroutine:NLNEGetRangeXForm}\\
\\
\tt NLPGetNumberOfNonlinearElements&\pageref{Subroutine:NLPGetNumberOfNonlinearElements}\\
\end{tabular}
\end{center}

\subsubsection{The list of groups}

\begin{center}
\begin{tabular}{ll}
\tt NLPGetNumberOfGroups&\pageref{Subroutine:NLPGetNumberOfGroups}\\
\tt NLPGetTypeOfGroup&\pageref{Subroutine:NLPGetTypeOfGroup}\\
\tt NLPGetGroupTypeName&\pageref{Subroutine:NLPGetGroupTypeName}\\
\tt NLPGetGroupName&\pageref{Subroutine:NLPGetGroupName}\\
\tt NLPSetGroupFunction&\pageref{Subroutine:NLPSetGroupFunction}\\
\tt NLPGetGroupFunction&\pageref{Subroutine:NLPGetGroupFunction}\\
\tt NLPIsGroupFunctionSet&\pageref{Subroutine:NLPIsGroupFunctionSet}\\
\tt NLPSetGroupA&\pageref{Subroutine:NLPSetGroupA}\\
\tt NLPGetGroupA&\pageref{Subroutine:NLPGetGroupA}\\
\tt NLPIsGroupASet&\pageref{Subroutine:NLPIsGroupASet}\\
\tt NLPSetGroupB&\pageref{Subroutine:NLPSetGroupB}\\
\tt NLPGetGroupB&\pageref{Subroutine:NLPGetGroupB}\\
\tt NLPIsGroupBSet&\pageref{Subroutine:NLPIsGroupBSet}\\
\tt NLPSetGroupScale&\pageref{Subroutine:NLPSetGroupScale}\\
\tt NLPGetGroupScale&\pageref{Subroutine:NLPGetGroupScale}\\
\end{tabular}
\end{center}

\subsubsection{The nonlinear elements (of each group)}

\begin{center}
\begin{tabular}{ll}
\tt NLPAddNonlinearElementToGroup&\pageref{Subroutine:NLPAddNonlinearElementToGroup}\\
\tt NLPGetElementWeight&\pageref{Subroutine:NLPGetElementWeight}\\
\tt NLPSetElementWeight&\pageref{Subroutine:NLPSetElementWeight}\\
\tt NLPIsElementWeightSet&\pageref{Subroutine:NLPIsElementWeightSet}\\
\tt NLPGetElementFunctionOfGroup&\pageref{Subroutine:NLPGetElementFunctionOfGroup}\\
\tt NLPGetGroupNonlinearElement&\pageref{Subroutine:NLPGetGroupNonlinearElement}\\
\tt NLPGetElementFunction&\pageref{Subroutine:NLPGetElementFunction}\\
\tt NLPSetElementFunction&\pageref{Subroutine:NLPSetElementFunction}\\
\tt NLPSetElementFunctionWithRange&\pageref{Subroutine:NLPSetElementFunctionWithRange}\\
\tt NLPIsElementFunctionSet&\pageref{Subroutine:NLPIsElementFunctionSet}\\
\tt NLPGetElementRangeTransformationOfGroup&\pageref{Subroutine:NLPGetElementRangeTransformationOfGroup}\\
\tt NLPGetElementRangeTransformation&\pageref{Subroutine:NLPGetElementRangeTransformation}\\
\tt NLPGetNumberOfInternalVariablesInElement&\pageref{Subroutine:NLPGetNumberOfInternalVariablesInElement}\\
\tt NLPGetElementIndexIntoWhole&\pageref{Subroutine:NLPGetElementIndexIntoWhole}\\
\tt NLPGetElementNumberOfUnknowns&\pageref{Subroutine:NLPGetElementNumberOfUnknowns}\\
\tt NLPGetNumberOfElementsInGroup&\pageref{Subroutine:NLPGetNumberOfElementsInGroup}\\
\tt NLPGetNumberOfElements&\pageref{Subroutine:NLPGetNumberOfElements}\\
\tt NLPGetNumberOfElementsO&\pageref{Subroutine:NLPGetNumberOfElementsO}\\
\tt NLPGetNumberOfElementsE&\pageref{Subroutine:NLPGetNumberOfElementsE}\\
\tt NLPGetNumberOfElementsI&\pageref{Subroutine:NLPGetNumberOfElementsI}\\
\tt NLPGetElementTypeName&\pageref{Subroutine:NLPGetElementTypeName}\\
\tt NLPGetTypeOfElement&\pageref{Subroutine:NLPGetTypeOfElement}\\
\end{tabular}
\end{center}
\newpage

\subsubsection{The list of Types}

\begin{center}
\begin{tabular}{ll}
\tt NLPGetNumberOfElementTypes&\pageref{Subroutine:NLPGetNumberOfElementTypes}\\
\tt NLPGetElementType&\pageref{Subroutine:NLPGetElementType}\\
\tt NLPGetNumberOfGroupTypes&\pageref{Subroutine:NLPGetNumberOfGroupTypes}\\
\tt NLPGetGroupType&\pageref{Subroutine:NLPGetGroupType}\\
\end{tabular}
\end{center}

\subsection{Lancelot}

\subsubsection{Construction}
\begin{center}
\begin{tabular}{ll}
\tt NLCreateLancelot&\pageref{Subroutine:NLCreateLancelot}\\
\tt NLRefLancelot&\pageref{Subroutine:NLRefLancelot}\\
\tt NLFreeLancelot&\pageref{Subroutine:NLFreeLancelot}\\
\end{tabular}
\end{center}

\subsubsection{Solving Problems}

\begin{center}
\begin{tabular}{ll}
\tt LNMinimize&\pageref{Subroutine:LNMinimize}\\
\tt LNMaximize&\pageref{Subroutine:LNMaximize}\\
\end{tabular}
\end{center}

\subsubsection{Setting LANCELOT Parameters}

\begin{center}
\begin{tabular}{ll}
\tt LNSetCheckDerivatives&\pageref{Subroutine:LNSetCheckDerivatives}\\
\tt LNGetCheckDerivatives&\pageref{Subroutine:LNGetCheckDerivatives}\\
\tt LNSetConstraintAccuracy&\pageref{Subroutine:LNSetConstraintAccuracy}\\
\tt LNGetConstraintAccuracy&\pageref{Subroutine:LNGetConstraintAccuracy}\\
\tt LNSetFirstConstraintAccuracy&\pageref{Subroutine:LNSetFirstConstraintAccuracy}\\
\tt LNGetFirstConstraintAccuracy&\pageref{Subroutine:LNGetFirstConstraintAccuracy}\\
\tt LNSetFirstGradientAccuracy&\pageref{Subroutine:LNSetFirstGradientAccuracy}\\
\tt LNGetFirstGradientAccuracy&\pageref{Subroutine:LNGetFirstGradientAccuracy}\\
\tt LNSetGradientAccuracy&\pageref{Subroutine:LNSetGradientAccuracy}\\
\tt LNGetGradientAccuracy&\pageref{Subroutine:LNGetGradientAccuracy}\\
\tt LNSetInitialPenalty&\pageref{Subroutine:LNSetInitialPenalty}\\
\tt LNGetInitialPenalty&\pageref{Subroutine:LNGetInitialPenalty}\\
\tt LNSetMaximumNumberOfIterations&\pageref{Subroutine:LNSetMaximumNumberOfIterations}\\
\tt LNGetMaximumNumberOfIterations&\pageref{Subroutine:LNGetMaximumNumberOfIterations}\\
\tt LNSetPenaltyBound&\pageref{Subroutine:LNSetPenaltyBound}\\
\tt LNGetPenaltyBound&\pageref{Subroutine:LNGetPenaltyBound}\\
\tt LNSetPrintEvery&\pageref{Subroutine:LNSetPrintEvery}\\
\tt LNGetPrintEvery&\pageref{Subroutine:LNGetPrintEvery}\\
\tt LNSetPrintLevel&\pageref{Subroutine:LNSetPrintLevel}\\
\tt LNGetPrintLevel&\pageref{Subroutine:LNGetPrintLevel}\\
\tt LNSetPrintStart&\pageref{Subroutine:LNSetPrintStart}\\
\tt LNGetPrintStart&\pageref{Subroutine:LNGetPrintStart}\\
\tt LNSetPrintStop&\pageref{Subroutine:LNSetPrintStop}\\
\tt LNGetPrintStop&\pageref{Subroutine:LNGetPrintStop}\\
\tt LNSetRequireExactCauchyPoint&\pageref{Subroutine:LNSetRequireExactCauchyPoint}\\
\tt LNGetRequireExactCauchyPoint&\pageref{Subroutine:LNGetRequireExactCauchyPoint}\\
\tt LNSetSaveDataEvery&\pageref{Subroutine:LNSetSaveDataEvery}\\
\tt LNGetSaveDataEvery&\pageref{Subroutine:LNGetSaveDataEvery}\\
\end{tabular}
\end{center}
\newpage
\begin{center}
\begin{tabular}{ll}
\tt LNSetScalings&\pageref{Subroutine:LNSetScalings}\\
\tt LNGetScalings&\pageref{Subroutine:LNGetScalings}\\
\tt LNSetSolveBQPAccurately&\pageref{Subroutine:LNSetSolveBQPAccurately}\\
\tt LNGetSolveBQPAccurately&\pageref{Subroutine:LNGetSolveBQPAccurately}\\
\tt LNSetLinearSolverMethod&\pageref{Subroutine:LNSetLinearSolverMethod}\\
\tt LNGetLinearSolverMethod&\pageref{Subroutine:LNGetLinearSolverMethod}\\
\tt LNGetLinearSolverBandwidth&\pageref{Subroutine:LNGetLinearSolverBandwidth}\\
\tt LNSetStopOnBadDerivatives&\pageref{Subroutine:LNSetStopOnBadDerivatives}\\
\tt LNGetStopOnBadDerivatives&\pageref{Subroutine:LNGetStopOnBadDerivatives}\\
\tt LNSetTrustRegionRadius&\pageref{Subroutine:LNSetTrustRegionRadius}\\
\tt LNGetTrustRegionRadius&\pageref{Subroutine:LNGetTrustRegionRadius}\\
\tt LNSetTrustRegionType&\pageref{Subroutine:LNSetTrustRegionType}\\
\tt LNGetTrustRegionType&\pageref{Subroutine:LNGetTrustRegionType}\\
\tt LNSetUseExactFirstDerivatives&\pageref{Subroutine:LNSetUseExactFirstDerivatives}\\
\tt LNGetUseExactFirstDerivatives&\pageref{Subroutine:LNGetUseExactFirstDerivatives}\\
\tt LNSetUseExactSecondDerivatives&\pageref{Subroutine:LNSetUseExactSecondDerivatives}\\
\tt LNGetUseExactSecondDerivatives&\pageref{Subroutine:LNGetUseExactSecondDerivatives}\\
\end{tabular}
\end{center}
%%---------------------------------------------------------------------------
\newpage
\leftline{\bf NLCreateProblem}
\label{Subroutine:NLCreateProblem}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLProblem data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it P}=NLCreateProblem({\it probName},{\it nV});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char &*{\it probName}&\parbox[t]{\SYNTAX}{The problem name, used on reports.}\\
\tt int &{\it nV}&\parbox[t]{\SYNTAX}{The number of variables in the problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Problem} allocates and initializes an NLProblem data structure.
The problem as initialized has no nonlinear constraints, no bounds
on the variables or objective, and no groups in the objective. Note that this
is not a valid problem. Lancelot will be invoked, but will issue an error 
unles a group is added to the objective. 

A problem should be deleted using the routine {\tt NLFree\-Problem} 
(page \pageref{Subroutine:NLFreeProblem}) when
it is no longer needed. This returns all storage used by the problem.\vskip .1in
\leftline{\bf Errors}
Severity 12 errors return (NLProblem)NULL, severity 4 returns a problem with no
name.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem name (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Number of Variables \%d (argument 2) must be positive"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefProblem}
\label{Subroutine:NLRefProblem}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Releases storage associated with an NLProblem data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefProblem({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLRef\-Problem} adds a reference to a problem. {\tt NLFree\-Problem} 
(page \pageref{Subroutine:NLFreeProblem})
removes one reference and releases the storage associated with the problem
if the reference count is zero. This allows the user to make a copy of the 
problem (the NLProblem is a pointer), and not have it disappear until 
sometime after the user calls {\tt NLFree\-Problem}.\vskip .1in
\leftline{\bf Errors}
Errors return without changing the problem.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLFreeProblem}
\label{Subroutine:NLFreeProblem}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Releases storage associated with an NLProblem data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeProblem({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLFree\-Problem} 
removes one reference and releases the storage associated with the problem
if the reference count is zero. 
The routine
{\tt NLRef\-Problem} (page \pageref{Subroutine:NLRefProblem}) adds a reference to a problem.
This allows the user to make a copy of the 
problem (the NLProblem is a pointer), and not have it disappear until 
sometime after the user calls {\tt NLFree\-Problem}.\vskip .1in

\leftline{\bf Errors}
Errors return without changing the problem.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPrintProblem}
\label{Subroutine:NLPrintProblem}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Prints a NLProblem data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLPrintProblem({\it fid},{\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt FILE &*{\it fid}&\parbox[t]{\SYNTAX}{The output file.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLPrint\-Problem} prints an NLProblem data structure. The output attempts
to mimic the SIF decoders printing.\vskip .1in
\leftline{\bf Errors}
Errors return without printing the problem.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"File pointer (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Problem (argument 2) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPrintProblemShort}
\label{Subroutine:NLPrintProblemShort}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Prints a NLProblem data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLPrintProblemShort({\it fid},{\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt FILE &*{\it fid}&\parbox[t]{\SYNTAX}{The output file.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLPrint\-Problem} prints an NLProblem data structure. The output attempts
to give a compact version of the problem.
\leftline{\bf Errors}
Errors return without printing the problem.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"File pointer (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Problem (argument 2) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetProblemName}
\label{Subroutine:NLPGetProblemName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetProblemName({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The problem name.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a problem, which was passed to the
{\tt NLCreate\-Problem} (page \pageref{Subroutine:NLCreateProblem}) subroutine. 

Note: The user should not free the returned string.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfVariables}
\label{Subroutine:NLPGetNumberOfVariables}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of variables for a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfVariables({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of variables.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of variables for a problem. This is set when
the {\tt NLCreate\-Problem} (page \pageref{Subroutine:NLCreateProblem}) subroutine
is called.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetVariableScale}
\label{Subroutine:NLPSetVariableScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the scale factor of a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetVariableScale({\it P},{\it i},{\it s});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The variable.}\\
\tt double&\it s&\parbox[t]{\SYNTAX}{The scale factor.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the scale factor of a variable. This can be queried with
the {\tt NLPGet\-Variable\-Scale} (page \pageref{Subroutine:NLPGetVariableScale})
subroutine. The default value is 1.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetVariableScale}
\label{Subroutine:NLPGetVariableScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the scale factor of a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it s}=NLPGetVariableScale({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it s&\parbox[t]{\SYNTAX}{The scale factor.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the scale factor of a variable. This is set with
the {\tt NLPSet\-Variable\-Scale} (page \pageref{Subroutine:NLPSetVariableScale})
subroutine. The default value is 1.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12
\\
\end{tabular}
\newpage
\leftline{\bf NLPSetVariableName}
\label{Subroutine:NLPSetVariableName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Assigns the name of a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetVariableName({\it P},{\it i},{\it name});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the variable.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The problem name.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the name of a variable. This may be queried with the
{\tt NLPSet\-Variable\-Name} subroutine (page \pageref{Subroutine:NLPSetVariableName}).
If the variable has not yet 
been given a name, the default is ``Xxxxxxxx'', where 'x' is a hex 
digit 0-9A-F. This is create with the C-format ``X%7.7x''. 

A copy of the string is made. The copy is freed when the problem is freed.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"The pointer to the variable name (argument 3) is NULL."}&4\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetVariableName}
\label{Subroutine:NLPGetVariableName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetVariableName({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The problem name.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a variable. If the variable has not yet 
been given a name, the default is ``Xxxxxxxx'', where 'x' is a hex 
digit 0-9A-F. This is create with the C-format ``X%7.7x''. 

Note: The user should not free the returned string.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12
\\
\end{tabular}
\newpage
\leftline{\bf NLPSetSimpleBounds}
\label{Subroutine:NLPSetSimpleBounds}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the bounds on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetSimpleBounds({\it P},{\it var},{\it l},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets both of the bounds on the variable. These can
be queried with the 
{\tt NLPGet\-Upper\-Simple\-Bound} (page \pageref{Subroutine:NLPGetUpperSimpleBound})
and 
{\tt NLPGet\-Lower\-Simple\-Bound} (page \pageref{Subroutine:NLPGetLowerSimpleBound})
subroutines. The bounds can also be set one at a time using the 
{\tt NLPSet\-Lower\-Simple\-Bound} (page \pageref{Subroutine:NLPSetLowerSimpleBound})
and
{\tt NLPSet\-Upper\-Simple\-Bound} (page \pageref{Subroutine:NLPSetUpperSimpleBound})
routines.

Initially the bounds are infinite. A value greater than $1.e20$ is considered to be infinity
(and a value less than $-1.e20$ is minus infinity).\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetLowerSimpleBound}
\label{Subroutine:NLPSetLowerSimpleBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the lower bound on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetLowerSimpleBound({\it P},{\it var},{\it l});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the lower bound on the variable. This can
be queried with the 
{\tt NLPGet\-Lower\-Simple\-Bound} (page \pageref{Subroutine:NLPGetLowerSimpleBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-Simple\-Bounds} (page \pageref{Subroutine:NLPSetSimpleBounds})
routine.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetLowerSimpleBound}
\label{Subroutine:NLPGetLowerSimpleBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the lower bound on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it l}=NLPGetLowerSimpleBound({\it P},{\it var});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the lower bound on the variable.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsLowerSimpleBoundSet}
\label{Subroutine:NLPIsLowerSimpleBoundSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether a lower bound has been set on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsLowerSimpleBoundSet({\it P},{\it var});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{The index of the variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether a lower bound has been set on a variable.
If it still has it's default value ($-\infty$), the routine
returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12
\\
\end{tabular}
\newpage
\leftline{\bf NLPSetUpperSimpleBound}
\label{Subroutine:NLPSetUpperSimpleBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the upper bound on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetUpperSimpleBound({\it P},{\it var},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the upper bound on the variable. This can
be queried with the 
{\tt NLPGet\-Upper\-Simple\-Bound} (page \pageref{Subroutine:NLPGetUpperSimpleBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-Simple\-Bounds} (page \pageref{Subroutine:NLPSetSimpleBounds})
routine.

Initially the bound is $\infty$. (A value of $1.e20$ is considered to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetUpperSimpleBound}
\label{Subroutine:NLPGetUpperSimpleBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the upper bound on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it u}=NLPGetUpperSimpleBound({\it P},{\it var});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{Which variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine gets the upper bound on the variable.

Initially the bound is $\infty$. (A value of $1.e20$ is considered to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsUpperSimpleBoundSet}
\label{Subroutine:NLPIsUpperSimpleBoundSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether a upper bound has been set on a variable.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsUpperSimpleBoundSet({\it P},{\it var});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it var &\parbox[t]{\SYNTAX}{The index of the variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether a upper bound has been set on a variable.
If it still has it's default value ($\infty$), the routine
returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Variable number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12
\\
\end{tabular}
\newpage
\leftline{\bf NLConvertToEqualityAndBoundsOnly}
\label{Subroutine:NLConvertToEqualityAndBoundsOnly}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Eliminates the inequality constraints from a Problem by introducing
slack variables.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLConvertToEqualityAndBoundsOnly({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLConvert\-To\-Equality\-And\-Bounds\-Only} takes a problem and introduces
slack variables (one for each inequality constraint) to convert the inequality
constraints into equality constraints. That is, an inequality constraint with
both bounds
\begin{displaymath}
 l\leq f({\bf v})\leq u
\end{displaymath}
is replaced by an equality constraint and simple bounds on the slack --
\begin{displaymath}
 \begin{array}{l}
  \displaystyle f({\bf v})-s =0 \\
  \displaystyle 0\leq s \leq u-l\\
 \end{array}
\end{displaymath}
An inequality constraint with only an upper bound
\begin{displaymath}
 f({\bf v})\leq u
\end{displaymath}
is replaced by an equality constraint and simple bounds on the slack --
\begin{displaymath}
 \begin{array}{l}
  \displaystyle f({\bf v})+s =u \\
  \displaystyle 0\leq s \\
 \end{array}
\end{displaymath}
And finally, an inequality constraint with only a lower bound
\begin{displaymath}
 l\leq f({\bf v})\leq u
\end{displaymath}
is replaced by an equality constraint and simple bounds on the slack --
\begin{displaymath}
 \begin{array}{l}
  \displaystyle f({\bf v})-s =l \\
  \displaystyle 0\leq s \\
 \end{array}
\end{displaymath}

The way this is currently done requires that the inequality constraints have a single group with a
trivial group function (this is true if the high level routines like NLPAddInequalityConstraint are used).

\leftline{\bf Errors}
Severity 12 errors return (NLProblem)NULL, severity 4 returns a problem with no
name.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Inequality Constraint \%d has \%d groups, only one is allowed currently and it must be the trivial group function"}&4\\
\parbox[t]{\ERRORMSG}{"Inequality Constraint \%d group must currently have the trivial group function"}&4\\

\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCopyProblem}
\label{Subroutine:NLCopyProblem}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Creates a copy of an NLProblem data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt Q=NLCopyProblem({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLProblem&\it Q &\parbox[t]{\SYNTAX}{The copy.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCopy\-Problem} makes a ``shallow'' copy of a problem. That is, the lists of constraints
are duplicated, but the functions defining the objective and constraints (the group and element
functions) are not. 

\leftline{\bf Errors}
Severity 12 errors return (NLProblem)NULL, severity 4 returns a problem with no
name.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateAugmentedLagrangian}
\label{Subroutine:NLCreateAugmentedLagrangian}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Replaces the equality constraints in a Problem with a quadratic penalty and Lagrangian terms in
the objective.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLCreateAugmentedLagrangian({\it P},{\it mu},{\it l}, {\it g},{\it b},{\it s});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt double&\it mu &\parbox[t]{\SYNTAX}{The penalty parameter $\mu$.}\\
\tt double*&\it l &\parbox[t]{\SYNTAX}{The Lagrange multipliers $\lambda_i$. Array must be at least of length
{\tt nc} (the number of equality constraints), }\\
\tt int*&\it g &\parbox[t]{\SYNTAX}{The indices of the new groups in the objective (values returned). The user is 
responsible for allocating this array. Array must be at least of length {\tt nc} (the number of equality constraints), }\\
\tt double*&\it b &\parbox[t]{\SYNTAX}{The constant elements of the equality constraints (values returned). The user is 
responsible for allocating this array. Array must be at least of length {\tt nc} (the number of equality constraints), }\\
\tt double*&\it s &\parbox[t]{\SYNTAX}{The group scales of the equality constraints (values returned). The user is 
responsible for allocating this array. Array must be at least of length {\tt nc} (the number of equality constraints), }\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Augmented\-Lagrangian} takes a problem and replaces
the equality constraints with a quadratic penalty function and lagrangian 
in the objective. That is, a problem
\begin{displaymath}
 \begin{array}{l}
  \displaystyle{\rm minimize~} O({\bf v})\\
\\
  \displaystyle f_i({\bf v})=0\\
 \end{array}
\end{displaymath}
is replaced by a problem with no equality constraints and objective --
\begin{displaymath}
  {\rm minimize~} O({\bf v}) + {1\over{2\mu}} \sum \left( f_i({\bf v}) - \mu\lambda_i\right)
\end{displaymath}
The Lagrange multipliers $\lambda_i$ (on for each equality constraint) are not problem variables,
but are treated as parameters in the objective (as is the penalty parameter $\mu$).

The Lagrange multipliers and penalty parameter are given the values passed. They may be changed with the
{\tt NLSet\-Lambda\-And\-Mu\-In\-Augmented\-Lagrangian} routine
(page \pageref{Subroutine:NLSetLambdaAndMuInAugmentedLagrangian}). The arrays {\it g}, {\it b}
and {\it s} which are filled in by this routine must be passed to that routine.

\leftline{\bf Errors}
Severity 12 errors return (NLProblem)NULL, severity 4 returns a problem with no
name.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Equality Constraint \%d has \%d groups. This is not supported yet."}&12\\
\parbox[t]{\ERRORMSG}{"Equality Constraint \%d has a nontrivial group function. This is not supported yet."}&12\\

\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLSetLambdaAndMuInAugmentedLagrangian}
\label{Subroutine:NLSetLambdaAndMuInAugmentedLagrangian}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the penalty parameter and LLagrange multipliers n a Problem with a quadratic penalty and Lagrangian
terms in the objective.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLSetLambdaAndMuInAugmentedLagrangian({\it P},{\it mu},{\it l}, {\it g},{\it b},{\it s});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt double&\it mu &\parbox[t]{\SYNTAX}{The penalty parameter $\mu$.}\\
\tt double*&\it l &\parbox[t]{\SYNTAX}{The Lagrange multipliers $\lambda_i$. Array must be at least of length
{\tt nc} (the number of equality constraints), }\\
\tt int*&\it g &\parbox[t]{\SYNTAX}{The indices of the new groups in the objective. This 
array must be the one returned by the Create\-Augmented\-Lagrangian routine, }\\
\tt double*&\it b &\parbox[t]{\SYNTAX}{The constant elements of the equality constraints. This
array must be the one returned by the Create\-Augmented\-Lagrangian routine, }\\
\tt double*&\it s &\parbox[t]{\SYNTAX}{The group scales of the equality constraints. This
array must be the one returned by the Create\-Augmented\-Lagrangian routine, }\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLSet\-Lambda\-And\-Mu\-In\-Augmented\-Lagrangian} changes the objective in a problem with augmented 
lagrangian, setting new values of the penalty parameter $\mu$ and Lagrange multipliers $\lambda_i$.

The arrays {\it g}, {\it b} and {\it s} must be those rteuned by the
{\tt NLCreate\-Augmented\-Lagrangian} routine (page \pageref{Subroutine:NLCreateAugmentedLagrangian}).

\leftline{\bf Errors}
Severity 12 errors return (NLProblem)NULL, severity 4 does not cahnge the problem.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLEliminateFixedVariables}
\label{Subroutine:NLEliminateFixedVariables}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent For each variable whose upper and lower simple bounds are identical, introduces a linear equality constraint
and removes the bounds.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLEliminateFixedVariables({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLEliminate\-Fixed\-Variables} takes a problem and for each variable whose upper and lower simple bounds
are identical, introduces a linear equality constraint and removes the bounds. That is, a problem with a
variable
\begin{displaymath}
  l_i\leq x_i \leq u_i
\end{displaymath}
with $l_i=u_i$ acquires an additional equality constraint
\begin{displaymath}
  x_i = u_i
\end{displaymath}
and the bounds on $x_i$ are removed.
\leftline{\bf Errors}
Severity 12 errors return (NLProblem)NULL, severity 4 returns a problem with no
name.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjective}
\label{Subroutine:NLPSetObjective}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the objective to be a function defined by a subroutine (and it's derivatives).
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLPSetObjective({\it P},{\it name},{\it nv},{\it v},{\it f},{\it df},{\it ddf},{\it data},{\it freeData});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char* \it name&\parbox[t]{\SYNTAX}{A name given to the objective ("Obj" might be a good choice.)}\\
\tt int \it nv&\parbox[t]{\SYNTAX}{The dimension of the domain of the objective. This provides some degree of
sparsity.}\\
\tt int*\it v&\parbox[t]{\SYNTAX}{A list of length {\it nv} of the problem variables that the objective depends on.
When the objective is evaluated the routines are passed the values of these problem variables in this order.}\\
\tt double {\it f}\tt (int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the function.}\\
\tt double {\it df}\tt (int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the derivative of the function.}\\
\tt double {\it ddf}\tt (int,int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the second derivative of the function.}\\
\tt void *{\it data}&\parbox[t]{\SYNTAX}{A Data Block that is to be passed to the functions.}\\
\tt void {\it freeData}\tt (void*)&\parbox[t]{\SYNTAX}{A routine to free the data block.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLPSetObjective} sets the objective. The routines {\it f}, {\it df}, and {\it ddf} define the
objective function. These are scalar valued functions of a subset of the problem variables. The subset is defined
by way of the {\it nv}, and {\it v} arguments. When the objective is evaluated the routine {\it f} will be
called.
\begin{quote}
double {\it f}\tt (int {\it nv},double *{\it x},void *{\it data});
\end{quote}
The first argument to {\it f} will be {\it nv}. The second argument is an array {\it x} containing values of
problem
variables {\it v}[0],...{\it v}[{\it nv}-1]. The third argument is the void pointer to {\it data}. This allows the
user to write one subroutine which, perhaps, uses the number of variables to decide which value to return (e.g. the sum of
the squares of all the variables), or to pass parameters through the {\it data} block. The function returns the value
of the objective.

The routines {\it df}, and {\it ddf} are similar, but with additional arguments for the derivatives being requested
\begin{quote}
double {\it df}\tt (int {\it nv},int {\it i}, double *{\it x}, void *{\it data});
\end{quote}
returns $\partial f/\partial x_i$. And
\begin{quote}
double {\it ddf}\tt (int {\it nv},int {\it i}, int {\it j}, double *{\it x}, void *{\it data});
\end{quote}
returns $\partial^2 f/\partial x_i\partial x_j$.

When the problem is free'd with {\tt NLFreeProblem}, and the reference count becomes zero, the {\it freedata}
routine will be called to allow the user to free the data block. 

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL, you must supply a problem."}&12\\
\parbox[t]{\ERRORMSG}{"name (second arg.) is NULL, you must supply a name for the constraint."}&12\\
\parbox[t]{\ERRORMSG}{"This problem already has an objective."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjectiveByString}
\label{Subroutine:NLPSetObjectiveByString}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the objective to be a function defined by a string.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLPSetObjectiveByString({\it P},{\it name},{\it nv},{\it v},{\it varlist},{\it expr});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char* \it name&\parbox[t]{\SYNTAX}{A name given to the objective ("Obj" might be a good choice.)}\\
\tt int \it nv&\parbox[t]{\SYNTAX}{The dimension of the domain of the objective. This provides some degree of
sparsity.}\\
\tt int*\it v&\parbox[t]{\SYNTAX}{A list of length {\it nv} of the problem variables that the objective depends on.}\\
\tt char* {\it varlist}&\parbox[t]{\SYNTAX}{A list of identifiers in the {\it expr}. When the expression is 
elvaluated these identifiers will be given the values of the problem variables listed in {\it v} (in the 
same order). The list is a single string, delimited by the characters ``['' and ``]'', and separated by commas.}\\
\tt char* {\it expr}&\parbox[t]{\SYNTAX}{An expression giving the objective.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLPSetObjectiveByString} sets the objective. The string {\it expr} defines the
objective function. When evaluated, the identifiers listed in {\it varlist} are given the values of
the problem variables listed in the array {\it v}. There should be {\it nv} entries in {\it v} and
in {\it varlist}. For example
\begin{verbatim}
 int v[3];
 v[0]=1;v[1]=45;v[2]=0;

 NLPSetObjective(P,"Obj",3,v, "[a,b,c]", "a**2+sqrt(cos(b))+1./c");
\end{verbatim}
will assign {\tt a} the value of problem variable 1, {\tt c} the value of problem variable 45,
and {\tt c} the value of problem variable 0. The main restriction on the expression is that
constants may {\it not} be specified using exponential notation (sorry). Elementary functions
and the usual binary operations can be used. Automatic differentiation is used to evaluate the derivatives.

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL, you must supply a problem."}&12\\
\parbox[t]{\ERRORMSG}{"name (second arg.) is NULL, you must supply a name for the constraint."}&12\\
\parbox[t]{\ERRORMSG}{"This problem already has an objective."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddGroupToObjective}
\label{Subroutine:NLPAddGroupToObjective}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a group to the objective function.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddGroupToObjective({\it P},{\it name},{\it type});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\tt char&*\it type &\parbox[t]{\SYNTAX}{The type of the new group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a group to the objective function. The {\it name}
of the group must be unique. The {\it type} need not be.

A trivial group is added, with no nonlinear element, and a zero linear element.
This can be added with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearElementToObjectiveGroup}
\label{Subroutine:NLPAddNonlinearElementToObjectiveGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an empty nonlinear element to a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it e}=NLPAddNonlinearElementToObjectiveGroup({\it P},{\it group},{\it type},{\it weight},{\it f},{\it variables},{\it xfrm});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it e&\parbox[t]{\SYNTAX}{The index of the new nonlinear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt char&*\it type &\parbox[t]{\SYNTAX}{The type of the new nonlinear element.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt NLElementFunction&\it f &\parbox[t]{\SYNTAX}{The element function or NULL.}\\
\tt int&\*it variables &\parbox[t]{\SYNTAX}{A list of the internal variables.}\\
\tt NLMatrix&\it xfrm &\parbox[t]{\SYNTAX}{The range transformation or NULL.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear element to a group in the objective.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjectiveGroupA}
\label{Subroutine:NLPSetObjectiveGroupA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the linear part of the linear element of a group in the objective.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetObjectiveGroupA({\it P},{\it group},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of a group in the objective. 
\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjectiveGroupB}
\label{Subroutine:NLPSetObjectiveGroupB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the constant part of the linear element of a group in the objective.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetObjectiveGroupB({\it P},{\it group},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt double&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the constant part of the linear element of a group in the objective.
The default value is zero.

Note: The definition uses a negative sign for the constant that might be counter
intuitive.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjectiveGroupFunction}
\label{Subroutine:NLPSetObjectiveGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the group function of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetObjectiveGroupFunction({\it P},{\it group},{\it g});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLGroupFunction&\it g&\parbox[t]{\SYNTAX}{The group function.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the group function of a group in the objective.
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Can't Set Trivial Group's Group Function, group \%d",group}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetObjectiveGroupScale}
\label{Subroutine:NLPSetObjectiveGroupScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the group function of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetObjectiveGroupScale({\it P},{\it group},{\it s});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt double&\it s&\parbox[t]{\SYNTAX}{The group scale factor.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the group scale of a group in the objective.
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfGroupsInObjective}
\label{Subroutine:NLPGetNumberOfGroupsInObjective}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of groups in the objective of a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfGroupsInObjective({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of groups.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the current number of groups in the objective of a 
problem. Each time a group is added to the objective this
number increases. It never decreases.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetObjectiveGroupNumber}
\label{Subroutine:NLPGetObjectiveGroupNumber}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of a group in the objective of a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPGetObjectiveGroupNumber({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of a group in the objective of a 
problem. Group queries use the group index. This routine can be
used to query the properties of all of the groups in the Objective.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPEvaluateObjective}
\label{Subroutine:NLPEvaluateObjective}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the objective function.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it o}=NLPEvaluateObjective({\it P},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double \it o&\parbox[t]{\SYNTAX}{The value of the objective function.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLVector \it x&\parbox[t]{\SYNTAX}{The point (problem variables) at which to evaluate the objective.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLP\-Evaluate\-Objective} evaluates the objective at a point {\it x} and returns the value.
The user must create the vector {\it x} and give it the appropriate values.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"x (second arg.) is NULL."}&12\\
\end{tabular}
1newpage
\leftline{\bf NLPEvaluateGradientOfObjective}
\label{Subroutine:NLPEvaluateGradientOfObjective}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the gradient of the objective function.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPEvaluateGradientOfObjective({\it P},{\it x},{\it g});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it rc&\parbox[t]{\SYNTAX}{The return code, 1 indicates success.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLVector \it x&\parbox[t]{\SYNTAX}{The point (problem variables) at which to evaluate the objective.}\\
\tt NLVector \it g&\parbox[t]{\SYNTAX}{The gradient of the objective. (The user passes the NLVector, which is
given a value by the routine.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLP\-Evaluate\-Gradient\-Of\-Objective} evaluates the gradient of the 
objective at a point {\it x} and returns the value.
The user must create the vectors {\it x} and {\it g}, and give {\it x} the appropriate values.
The routine sets the values in the gradient {\it g}. Note that if a sparse vector is passed in
the gradient is returned in a sparse vector. If a dense vector is passed the result is returned in
a dense vector.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"x (second arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"g (third arg.) is NULL."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPEvaluateHessianOfObjective}
\label{Subroutine:NLPEvaluateHessianOfObjective}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the Hessian of the objective function.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPEvaluateHessianOfObjective({\it P},{\it x},{\it H});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it rc&\parbox[t]{\SYNTAX}{The return code, 1 indicates success.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLVector \it x&\parbox[t]{\SYNTAX}{The point (problem variables) at which to evaluate the objective.}\\
\tt NLMatrix \it H&\parbox[t]{\SYNTAX}{The Hessian of the objective. (The user passes the NLMatrix, which is
given a value by the routine.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLP\-Evaluate\-Hessian\-Of\-Objective} evaluates the Hessian of the 
objective at a point {\it x} and returns the value.
The user must create the vectors {\it x} and {\it H}, and give {\it x} the appropriate values.
The routine sets the values in the Hessian {\it H}. Note that the user determines the format
of the Hessian when the NLMatrix is created.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"x (second arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"H (third arg.) is NULL."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddEqualityConstraint}
\label{Subroutine:NLPAddEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an equality constraint defined by a subroutine (and it's derivatives) to a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLPAddEqualityConstraint({\it P},{\it name},{\it nv},{\it v},{\it f},{\it df},{\it ddf},{\it data},{\it freeData});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it c&\parbox[t]{\SYNTAX}{The number assigned to the new constraint.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char* \it name&\parbox[t]{\SYNTAX}{A name given to the constraint.}\\
\tt int \it nv&\parbox[t]{\SYNTAX}{The dimension of the domain of the constraint. This provides some degree of
sparsity.}\\
\tt int*\it v&\parbox[t]{\SYNTAX}{A list of length {\it nv} of the problem variables that the constraint depends on.
When the constraint is evaluated the routines are passed the values of these problem variables in this order.}\\
\tt double {\it f}\tt (int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the function.}\\
\tt double {\it df}\tt (int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the derivative of the function.}\\
\tt double {\it ddf}\tt (int,int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the second derivative of the function.}\\
\tt void *{\it data}&\parbox[t]{\SYNTAX}{A Data Block that is to be passed to the functions.}\\
\tt void {\it freeData}\tt (void*)&\parbox[t]{\SYNTAX}{A routine to free the data block.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLPAdd\-Equality\-Constraint} adds an equality constraint. The routines {\it f}, {\it df}, and {\it ddf} define the
constraint function. These are scalar valued functions of a subset of the problem variables. The subset is defined
by way of the {\it nv}, and {\it v} arguments. When the constraint is evaluated the routine {\it f} will be
called.
\begin{quote}
double {\it f}\tt (int {\it nv},double *{\it x},void *{\it data});
\end{quote}
The first argument to {\it f} will be {\it nv}. The second argument is an array {\it x} containing values of
problem
variables {\it v}[0],...{\it v}[{\it nv}-1]. The third argument is the void pointer to {\it data}. This allows the
user to write one subroutine which, perhaps, uses the number of variables to decide which value to return (e.g. the sum of
the squares of all the variables), or to pass parameters through the {\it data} block. The function returns the value
of the constraint.

The routines {\it df}, and {\it ddf} are similar, but with additional arguments for the derivatives being requested
\begin{quote}
double {\it df}\tt (int {\it nv},int {\it i}, double *{\it x}, void *{\it data});
\end{quote}
returns $\partial f/\partial x_i$. And
\begin{quote}
double {\it ddf}\tt (int {\it nv},int {\it i}, int {\it j}, double *{\it x}, void *{\it data});
\end{quote}
returns $\partial^2 f/\partial x_i\partial x_j$.

When the problem is free'd with {\tt NLFreeProblem}, and the reference count becomes zero, the {\it freedata}
routine will be called to allow the user to free the data block. 

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL, you must supply a problem."}&12\\
\parbox[t]{\ERRORMSG}{"name (second arg.) is NULL, you must supply a name for the constraint."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddEqualityConstraintByString}
\label{Subroutine:NLPAddEqualityConstraintByString}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an equality constraint defined by an expression in a string to a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLPAddEqualityConstraintByString({\it P},{\it name},{\it nv},{\it v},{\it varlist},{\it expr});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it c&\parbox[t]{\SYNTAX}{The number assigned to the new constraint.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char* \it name&\parbox[t]{\SYNTAX}{A name given to the constraint.}\\
\tt int \it nv&\parbox[t]{\SYNTAX}{The dimension of the domain of the constraint. This provides some degree of
sparsity.}\\
\tt int*\it v&\parbox[t]{\SYNTAX}{A list of length {\it nv} of the problem variables that the constraint depends on.}\\
\tt char* {\it varlist}&\parbox[t]{\SYNTAX}{A list of identifiers in the {\it expr}. When the expression is 
elvaluated these identifiers will be given the values of the problem variables listed in {\it v} (in the 
same order). The list is a single string, delimited by the characters ``['' and ``]'', and separated by commas.}\\
\tt char* {\it expr}&\parbox[t]{\SYNTAX}{An expression giving the constraint.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLPAdd\-Equality\-Constraint\-By\-String} sets the constraint. The string {\it expr} defines the
constraint function. When evaluated, the identifiers listed in {\it varlist} are given the values of
the problem variables listed in the array {\it v}. There should be {\it nv} entries in {\it v} and
in {\it varlist}. For example
\begin{verbatim}
 int v[3];
 int c;

 v[0]=1;v[1]=45;v[2]=0;

 c=NLPAddEqualityConstraintByString(P,"Obj",3,v, "[a,b,c]", "a**2+sqrt(cos(b))+1./c");
\end{verbatim}
will assign {\tt a} the value of problem variable 1, {\tt c} the value of problem variable 45,
and {\tt c} the value of problem variable 0. The main restriction on the expression is that
constants may {\it not} be specified using exponential notation (sorry). Elementary functions
and the usual binary operations can be used. Automatic differentiation is used to evaluate the derivatives.

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL, you must supply a problem."}&12\\
\parbox[t]{\ERRORMSG}{"name (second arg.) is NULL, you must supply a name for the constraint."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearEqualityConstraint}
\label{Subroutine:NLPAddNonlinearEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a nonlinear equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddNonlinearEqualityConstraint({\it P},{\it name});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a 
nonlinear equality constraint.
The {\it name}
of the group must be unique. The {\it type} need not be.

A trivial group is added, with no nonlinear element, and a zero linear element.
This can be added with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddLinearEqualityConstraint}
\label{Subroutine:NLPAddLinearEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a linear equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddLinearEqualityConstraint({\it P},{\it name},{\it a},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\tt double&*\it a &\parbox[t]{\SYNTAX}{The linear part of the linear element.}\\
\tt double&\it b &\parbox[t]{\SYNTAX}{The constant part of the linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a 
linear equality constraint. That is, a constraint with the trivial group and
no nonlinear elements. This is a convenience routine, the same as invoking the
{{\tt NLPAddNonlinearEqualityConstraint} (page \pageref{Subroutine:NLPAddNonlinearEqualityConstraint}), 
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}), 
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.

The {\it name}
of the group must be unique. The {\it type} need not be.

A trivial group is added, with no nonlinear element, and the given linear element.
The constraint can be modified using the
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearElementToEqualityConstraint}
\label{Subroutine:NLPAddNonlinearElementToEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an empty nonlinear element to an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it e}=NLPAddNonlinearElementToEqualityConstraint({\it P},{\it constraint},{\it weight},{\it ne},{\it variables},{\it xfrm});}
int NLPAddNonlinearElementToEqualityConstraint(NLProblem P,int constraint,double w,LNNonlinearElement E);
\vskip .1in
\begin{tabular}{lll}
\tt int&\it e&\parbox[t]{\SYNTAX}{The index of the new nonlinear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt LNNonlinearElement&\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear element to an equality constraint.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Constraint \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetEqualityConstraintA}
\label{Subroutine:NLPSetEqualityConstraintA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the linear part of the linear element of an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetEqualityConstraintA({\it P},{\it constraint},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of an equality constraint.
\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetEqualityConstraintB}
\label{Subroutine:NLPSetEqualityConstraintB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the constant part of the linear element of an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetEqualityConstraintB({\it P},{\it constraint},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the constant part of the linear element of an equality constraint.
The default value is zero.

Note: The definition uses a negative sign for the constant that might be counter
intuitive.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfEqualityConstraints}
\label{Subroutine:NLPGetNumberOfEqualityConstraints}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of equality constraints in a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfEqualityConstraints({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of constraints.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the current number of equality constraints in a problem.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetEqualityConstraintGroupNumber}
\label{Subroutine:NLPGetEqualityConstraintGroupNumber}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of the group representing an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it group}=NLPGetEqualityConstraintGroupNumber({\it P},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it group&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of the group representing an equality constraint.
This is the same index that is returned by the 
{\tt NLPAdd\-Nonlinear\-Equality\-Constraint} (page \pageref{Subroutine:NLPAddNonlinearEqualityConstraint})
subroutine.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPEvaluateEqualityConstraint}
\label{Subroutine:NLPEvaluateEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it o}=NLPEvaluateEqualityConstraint({\it P},{\it c},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double \it o&\parbox[t]{\SYNTAX}{The value of the constraint.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt int \it c&\parbox[t]{\SYNTAX}{The number of the constraint to be evaluated.}\\
\tt NLVector \it x&\parbox[t]{\SYNTAX}{The point (problem variables) at which to evaluate the constraint.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLP\-Evaluate\-Equality\-Constraint} evaluates the constraint at a point {\it x} and returns the value.
The user must create the vector {\it x} and give it the appropriate values.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"x (second arg.) is NULL."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPEvaluateGradientOfEqualityConstraint}
\label{Subroutine:NLPEvaluateGradientOfEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the gradient of an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPEvaluateGradientOfEqualityConstraint({\it P},{\it c},{\it x},{\it g});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it rc&\parbox[t]{\SYNTAX}{The return code, 1 if successful.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt int \it c&\parbox[t]{\SYNTAX}{The number of the constraint.}\\
\tt NLVector \it x&\parbox[t]{\SYNTAX}{The point (problem variables) at which to evaluate the constraint.}\\
\tt NLVector \it g&\parbox[t]{\SYNTAX}{The gradient of the objective. (The user passes the NLVector, which is
given a value by the routine.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLP\-Evaluate\-Gradient\-Of\-Equality\-Constraint} evaluates the gradient of an 
equality constraint at a point {\it x} and returns the value.
The user must create the vectors {\it x} and {\it g}, and give {\it x} the appropriate values.
The routine sets the values in the gradient {\it g}. Note that if a sparse vector is passed in
the gradient is returned in a sparse vector. If a dense vector is passed the result is returned in
a dense vector.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"Constraint \%d (argument 2) is Invalid, must be in [0,\%d)."}&12\\
\parbox[t]{\ERRORMSG}{"x (second arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"g (third arg.) is NULL."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPEvaluateHessianOfEqualityConstraint}
\label{Subroutine:NLPEvaluateHessianOfEqualityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the Hessian of an equality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPEvaluateHessianOfEqualityConstraint({\it P},{\it c},{\it x},{\it H});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it rc&\parbox[t]{\SYNTAX}{The return code, 1 indicates success.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt int \it c&\parbox[t]{\SYNTAX}{The number of the constraint.}\\
\tt NLVector \it x&\parbox[t]{\SYNTAX}{The point (problem variables) at which to evaluate the objective.}\\
\tt NLMatrix \it H&\parbox[t]{\SYNTAX}{The Hessian of the objective. (The user passes the NLMatrix, which is
given a value by the routine.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLP\-Evaluate\-Hessian\-Of\-Equality\-Constraint} evaluates the Hessian of an 
equality constraint at a point {\it x} and returns the value.
The user must create the vectors {\it x} and {\it H}, and give {\it x} the appropriate values.
The routine sets the values in the Hessian {\it H}. Note that the user determines the format
of the Hessian when the NLMatrix is created.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"Constraint \%d (argument 2) is Invalid, must be in [0,\%d)."}&12\\
\parbox[t]{\ERRORMSG}{"x (second arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"H (third arg.) is NULL."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddInequalityConstraint}
\label{Subroutine:NLPAddInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an inequality constraint defined by a subroutine (and it's derivatives) to a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLPAddInequalityConstraint({\it P},{\it name},{\it l},{\it u},{\it nv},{\it v},{\it f},{\it df},{\it ddf},{\it data},{\it freeData});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it c&\parbox[t]{\SYNTAX}{The number assigned to the new constraint.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char* \it name&\parbox[t]{\SYNTAX}{A name given to the constraint.}\\
\tt double {\it l}&\parbox[t]{\SYNTAX}{The lower bound of the constraint. (Anything less than $-1.e20$ is taken
to be $-\infty$.)}\\
\tt double {\it u}&\parbox[t]{\SYNTAX}{The upper bound of the constraint. (Anything greater than $1.e20$ is taken
to be $\infty$.)}\\
\tt int \it nv&\parbox[t]{\SYNTAX}{The dimension of the domain of the constraint. This provides some degree of
sparsity.}\\
\tt int*\it v&\parbox[t]{\SYNTAX}{A list of length {\it nv} of the problem variables that the constraint depends on.
When the constraint is evaluated the routines are passed the values of these problem variables in this order.}\\
\tt double {\it f}\tt (int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the function.}\\
\tt double {\it df}\tt (int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the derivative of the function.}\\
\tt double {\it ddf}\tt (int,int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the second derivative of the function.}\\
\tt void *{\it data}&\parbox[t]{\SYNTAX}{A Data Block that is to be passed to the functions.}\\
\tt void {\it freeData}\tt (void*)&\parbox[t]{\SYNTAX}{A routine to free the data block.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLPAdd\-Inequality\-Constraint} adds an inequality constraint. The routines {\it f}, {\it df}, and {\it ddf} define the
constraint function. These are scalar valued functions of a subset of the problem variables. The subset is defined
by way of the {\it nv}, and {\it v} arguments. When the constraint is evaluated the routine {\it f} will be
called.
\begin{quote}
double {\it f}\tt (int {\it nv},double *{\it x},void *{\it data});
\end{quote}
The first argument to {\it f} will be {\it nv}. The second argument is an array {\it x} containing values of
problem
variables {\it v}[0],...{\it v}[{\it nv}-1]. The third argument is the void pointer to {\it data}. This allows the
user to write one subroutine which, perhaps, uses the number of variables to decide which value to return (e.g. the sum of
the squares of all the variables), or to pass parameters through the {\it data} block. The function returns the value
of the constraint.

The routines {\it df}, and {\it ddf} are similar, but with additional arguments for the derivatives being requested
\begin{quote}
double {\it df}\tt (int {\it nv},int {\it i}, double *{\it x}, void *{\it data});
\end{quote}
returns $\partial f/\partial x_i$. And
\begin{quote}
double {\it ddf}\tt (int {\it nv},int {\it i}, int {\it j}, double *{\it x}, void *{\it data});
\end{quote}
returns $\partial^2 f/\partial x_i\partial x_j$.

When the problem is free'd with {\tt NLFreeProblem}, and the reference count becomes zero, the {\it freedata}
routine will be called to allow the user to free the data block. 

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL, you must supply a problem."}&12\\
\parbox[t]{\ERRORMSG}{"name (second arg.) is NULL, you must supply a name for the constraint."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddInequalityConstraintByString}
\label{Subroutine:NLPAddInequalityConstraintByString}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an inequality constraint defined by an expression in a string to a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLPAddInequalityConstraintByString({\it P},{\it name},{\it l},{\it u},{\it nv},{\it v},{\it varlist},{\it expr});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it c&\parbox[t]{\SYNTAX}{The number assigned to the new constraint.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char* \it name&\parbox[t]{\SYNTAX}{A name given to the constraint.}\\
\tt double {\it l}&\parbox[t]{\SYNTAX}{The lower bound of the constraint. (Anything less than $-1.e20$ is taken
to be $-\infty$.)}\\
\tt double {\it u}&\parbox[t]{\SYNTAX}{The upper bound of the constraint. (Anything greater than $1.e20$ is taken
to be $\infty$.)}\\/
\tt int \it nv&\parbox[t]{\SYNTAX}{The dimension of the domain of the constraint. This provides some degree of
sparsity.}\\
\tt int*\it v&\parbox[t]{\SYNTAX}{A list of length {\it nv} of the problem variables that the constraint depends on.}\\
\tt char* {\it varlist}&\parbox[t]{\SYNTAX}{A list of identifiers in the {\it expr}. When the expression is 
elvaluated these identifiers will be given the values of the problem variables listed in {\it v} (in the 
same order). The list is a single string, delimited by the characters ``['' and ``]'', and separated by commas.}\\
\tt char* {\it expr}&\parbox[t]{\SYNTAX}{An expression giving the constraint.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLPAdd\-Inequality\-Constraint\-By\-String} sets the constraint. The string {\it expr} defines the
constraint function. When evaluated, the identifiers listed in {\it varlist} are given the values of
the problem variables listed in the array {\it v}. There should be {\it nv} entries in {\it v} and
in {\it varlist}. For example
\begin{verbatim}
 int v[3];
 int c;

 v[0]=1;v[1]=45;v[2]=0;

 c=NLPAddInequalityConstraintByString(P,"Obj",-2.e20,1., 3,v, "[a,b,c]", "a**2+sqrt(cos(b))+1./c");
\end{verbatim}
will assign {\tt a} the value of problem variable 1, {\tt c} the value of problem variable 45,
and {\tt c} the value of problem variable 0. The main restriction on the expression is that
constants may {\it not} be specified using exponential notation (sorry). Elementary functions
and the usual binary operations can be used. Automatic differentiation is used to evaluate the derivatives.

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL, you must supply a problem."}&12\\
\parbox[t]{\ERRORMSG}{"name (second arg.) is NULL, you must supply a name for the constraint."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearInequalityConstraint}
\label{Subroutine:NLPAddNonlinearInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a nonlinear inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddNonlinearInequalityConstraint({\it P},{\it name});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear inequality constraint.
The {\it name} of the group must be unique.

A trivial group is added, with no nonlinear element, and a zero linear element.
This information can be added with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.
Bounds can (and should be) set with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintLowerBound}),
{\tt NLPSet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintUpperBound}),
and
{\tt NLPSet\-Inequality\-Constraint\-Bounds} (page \pageref{Subroutine:NLPSetInequalityConstraintBounds})
subroutines.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddLinearInequalityConstraint}
\label{Subroutine:NLPAddLinearInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a linear inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPAddLinearInequalityConstraint({\it P},{\it name},{\it a},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it g&\parbox[t]{\SYNTAX}{The index of the new group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the new group.}\\
\tt double&*\it a &\parbox[t]{\SYNTAX}{The linear part of the linear element.}\\
\tt double&\it b &\parbox[t]{\SYNTAX}{The constant part of the linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a linear inequality constraint.
The {\it name} of the group must be unique.

A trivial group is added, with no nonlinear element, and the given linear element.
The constraint may be changed with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Group\-Scale} (page \pageref{Subroutine:NLPSetGroupScale}),
{\tt NLPSet\-GroupA} (page \pageref{Subroutine:NLPSetGroupA}),
and {\tt NLPSet\-GroupB} (page \pageref{Subroutine:NLPSetGroupB}) routines.
Bounds can (and should be) set with the 
{\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction}),
{\tt NLPSet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintLowerBound}),
{\tt NLPSet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintUpperBound}),
and
{\tt NLPSet\-Inequality\-Constraint\-Bounds} (page \pageref{Subroutine:NLPSetInequalityConstraintBounds})
subroutines.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearElementToInequalityConstraint}
\label{Subroutine:NLPAddNonlinearElementToInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an empty nonlinear element to an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it e}=NLPAddNonlinearElementToInequalityConstraint({\it P},{\it constraint},{\it weight},{\it ne},{\it variables},{\it xfrm});}
int NLPAddNonlinearElementToInequalityConstraint(NLProblem P,int constraint,double w,LNNonlinearElement E);
\vskip .1in
\begin{tabular}{lll}
\tt int&\it e&\parbox[t]{\SYNTAX}{The index of the new nonlinear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt LNNonlinearElement&\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear element to an inequality constraint.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Constraint \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintA}
\label{Subroutine:NLPSetInequalityConstraintA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the linear part of the linear element of an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintA({\it P},{\it constraint},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of an inequality constraint.
\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintB}
\label{Subroutine:NLPSetInequalityConstraintB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the constant part of the linear element of an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintB({\it P},{\it constraint},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it constraint &\parbox[t]{\SYNTAX}{The index of the constraint.}\\
\tt double&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the constant part of the linear element of an inequality constraint.
The default value is zero.

Note: The definition uses a negative sign for the constant that might be counter
intuitive.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetInequalityConstraintLowerBound}
\label{Subroutine:NLPGetInequalityConstraintLowerBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the lower bound for an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it l}=NLPGetInequalityConstraintLowerBound({\it P},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the lower bound for the inequality constraint.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintLowerBound}
\label{Subroutine:NLPSetInequalityConstraintLowerBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the lower bound on an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintLowerBound({\it P},{\it c},{\it l});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the lower bound on the inequality constraint. This can
be queried with the 
{\tt NLPGet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPGetInequalityConstraintLowerBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-Inequality\-Constraint\-Bounds} (page \pageref{Subroutine:NLPSetInequalityConstraintBounds})
routine.

Initially the bound is $-\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetInequalityConstraintUpperBound}
\label{Subroutine:NLPGetInequalityConstraintUpperBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the upper bound for an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it u}=NLPGetInequalityConstraintUpperBound({\it P},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine gets the upper bound for an inequality constraint.

Initially the bound is $\infty$. (A value of $1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintUpperBound}
\label{Subroutine:NLPSetInequalityConstraintUpperBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the upper bound on an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintUpperBound({\it P},{\it c},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the upper bound on the inequality constraint. This can
be queried with the 
{\tt NLPGet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPGetInequalityConstraintUpperBound})
subroutine. The bounds can also be set at the same time using the 
{\tt NLPSet\-Inequality\-Constraint\-Bounds} (page \pageref{Subroutine:NLPSetInequalityConstraintBounds})
routine.

Initially the bound is $\infty$. (A value of $1.e20$ is considered by Lancelot
to be infinity.)\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetInequalityConstraintBounds}
\label{Subroutine:NLPSetInequalityConstraintBounds}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the bounds on an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetInequalityConstraintBounds({\it P},{\it c},{\it l},{\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\tt double&\it l &\parbox[t]{\SYNTAX}{The lower bound.}\\
\tt double&\it u &\parbox[t]{\SYNTAX}{The upper bound.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the bounds on the inequality constraint. This can
be queried with the 
{\tt NLPGet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPGetInequalityConstraintUpperBound})
and
{\tt NLPGet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPGetInequalityConstraintLowerBound})
subroutine. The bounds can also be set one at a time using the 
{\tt NLPSet\-Inequality\-Constraint\-Upper\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintUpperBound})
and
{\tt NLPSet\-Inequality\-Constraint\-Lower\-Bound} (page \pageref{Subroutine:NLPSetInequalityConstraintLowerBound})
routines.

Initially the bounds are $-\infty$ to $\infty$. (A value of $-1.e20$ is considered by Lancelot
to be infinity.) Obviously this is no constraint at all unless the bounds are set.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfInequalityConstraints}
\label{Subroutine:NLPGetNumberOfInequalityConstraints}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of inequality constraints in a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfInequalityConstraints({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of constraints.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the current number of inequality constraints in a problem.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetInequalityConstraintGroupNumber}
\label{Subroutine:NLPGetInequalityConstraintGroupNumber}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of the group representing an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it group}=NLPGetInequalityConstraintGroupNumber({\it P},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it group&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it c &\parbox[t]{\SYNTAX}{Which constraint.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of the group representing an inequality constraint.
This is the same index that is returned by the 
{\tt NLPAdd\-Nonlinear\-Inequality\-Constraint} (page \pageref{Subroutine:NLPAddNonlinearInequalityConstraint})
subroutine.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Inequality constraint number \%d (argument 2) is illegal. Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPEvaluateInequalityConstraint}
\label{Subroutine:NLPEvaluateInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it o}=NLPEvaluateInequalityConstraint({\it P},{\it c},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double \it o&\parbox[t]{\SYNTAX}{The value of the constraint.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt int \it c&\parbox[t]{\SYNTAX}{The number of the constraint to be evaluated.}\\
\tt NLVector \it x&\parbox[t]{\SYNTAX}{The point (problem variables) at which to evaluate the constraint.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLP\-Evaluate\-Inequality\-Constraint} evaluates the constraint at a point {\it x} and returns the value.
The user must create the vector {\it x} and give it the appropriate values.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"x (second arg.) is NULL."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPEvaluateGradientOfInequalityConstraint}
\label{Subroutine:NLPEvaluateGradientOfInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the gradient of an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPEvaluateGradientOfInequalityConstraint({\it P},{\it c},{\it x},{\it g});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it rc&\parbox[t]{\SYNTAX}{The return code, 1 if successful.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt int \it c&\parbox[t]{\SYNTAX}{The number of the constraint.}\\
\tt NLVector \it x&\parbox[t]{\SYNTAX}{The point (problem variables) at which to evaluate the constraint.}\\
\tt NLVector \it g&\parbox[t]{\SYNTAX}{The gradient of the objective. (The user passes the NLVector, which is
given a value by the routine.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLP\-Evaluate\-Gradient\-Of\-Inequality\-Constraint} evaluates the gradient of an 
inequality constraint at a point {\it x} and returns the value.
The user must create the vectors {\it x} and {\it g}, and give {\it x} the appropriate values.
The routine sets the values in the gradient {\it g}. Note that if a sparse vector is passed in
the gradient is returned in a sparse vector. If a dense vector is passed the result is returned in
a dense vector.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"Constraint \%d (argument 2) is Invalid, must be in [0,\%d)."}&12\\
\parbox[t]{\ERRORMSG}{"x (second arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"g (third arg.) is NULL."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPEvaluateHessianOfInequalityConstraint}
\label{Subroutine:NLPEvaluateHessianOfInequalityConstraint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the Hessian of an inequality constraint.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPEvaluateHessianOfInequalityConstraint({\it P},{\it c},{\it x},{\it H});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it rc&\parbox[t]{\SYNTAX}{The return code, 1 indicates success.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt int \it c&\parbox[t]{\SYNTAX}{The number of the constraint.}\\
\tt NLVector \it x&\parbox[t]{\SYNTAX}{The point (problem variables) at which to evaluate the objective.}\\
\tt NLMatrix \it H&\parbox[t]{\SYNTAX}{The Hessian of the objective. (The user passes the NLMatrix, which is
given a value by the routine.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt NLP\-Evaluate\-Hessian\-Of\-Inequality\-Constraint} evaluates the Hessian of an 
inequality constraint at a point {\it x} and returns the value.
The user must create the vectors {\it x} and {\it H}, and give {\it x} the appropriate values.
The routine sets the values in the Hessian {\it H}. Note that the user determines the format
of the Hessian when the NLMatrix is created.
\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"Constraint \%d (argument 2) is Invalid, must be in [0,\%d)."}&12\\
\parbox[t]{\ERRORMSG}{"x (second arg.) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"H (third arg.) is NULL."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLError}
\label{Subroutine:NLError}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether an error condition exists.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLError();}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine checks to see if any routine has set an error condition.
\newpage
\leftline{\bf NLGetNErrors}
\label{Subroutine:NLGetNErrors}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of errors that have been flagged.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLGetNErrors();}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of errors.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of errors that have been set.
\newpage
\leftline{\bf NLGetErrorSev}
\label{Subroutine:NLGetErrorSev}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the severity of an error.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it sev}=NLGetErrorSev({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it sev &\parbox[t]{\SYNTAX}{The severity.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the severity of the $i$th error.
\newpage
\leftline{\bf NLGetErrorRoutine}
\label{Subroutine:NLGetErrorRoutine}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of the routine that issued an error.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it routine}=NLGetErrorRoutine({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it routine &\parbox[t]{\SYNTAX}{The name of the routine.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of the routine which issued the $i$th error.
\newpage
\leftline{\bf NLGetErrorMsg}
\label{Subroutine:NLGetErrorMsg}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the message associated with an error.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it msg}=NLGetErrorMsg({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it msg &\parbox[t]{\SYNTAX}{The message text.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the message associated with the $i$th error.
\newpage
\leftline{\bf NLGetErrorLine}
\label{Subroutine:NLGetErrorLine}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the statement at which an error occurred.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it stmt}=NLGetErrorLine({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it stmt &\parbox[t]{\SYNTAX}{The statement.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the statement at which the $i$th error occured.
\newpage
\leftline{\bf NLGetErrorFile}
\label{Subroutine:NLGetErrorFile}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the file containing the source code from which an error was issued.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it file}=NLGetErrorFile({\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it file &\parbox[t]{\SYNTAX}{The file.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which error.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the file containing the source code from which the $i$th error was issued.
\newpage
\leftline{\bf NLClearErrors}
\label{Subroutine:NLClearErrors}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Clears all errors.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLClearErrors();}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine clears the error stack.
\newpage
\leftline{\bf NLCreateVector}
\label{Subroutine:NLCreateVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLVector data structure of a given length.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLCreateVector({\it n});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The length of the vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Vector} allocates an NLVector data structure and initializes
it to a vector of given length with no non-zero coordinates. The coordinates
may be changed with the {\tt NLVSet\-C} routine (page 
\pageref{Subroutine:NLVSetC}). Vectors with supplied coordinate values can 
be created with the {\tt NLCreate\-Vector\-With\-Sparse\-Data} and 
{\tt NLCreate\-Vector\-With\-Full\-Data} subroutines (pages \pageref{Subroutine:NLCreateVectorWithSparseData} and \pageref{Subroutine:NLCreateVectorWithFullData}).

The NLVector data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Vector} subroutine 
(page \pageref{Subroutine:NLFreeVector}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Vector} subroutine (page 
\pageref{Subroutine:NLRefVector}).
\vskip .1in
\leftline{\bf Errors}
Severity 12 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Length of Vector \%d (argument 1) is Illegal. Must be positive."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateVectorWithSparseData}
\label{Subroutine:NLCreateVectorWithSparseData}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLVector data structure of a given length.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLCreateVectorWithSparseData({\it n},{\it nz},{\it el},{\it vl});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector &\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int &\it n &\parbox[t]{\SYNTAX}{The length of the vector.}\\
\tt int &\it nz &\parbox[t]{\SYNTAX}{The number of non-zeros in the vector.}\\
\tt int &*\it el &\parbox[t]{\SYNTAX}{The indices of the non-zero coordinates.}\\
\tt double &*\it vl &\parbox[t]{\SYNTAX}{The values of the non-zero coordinates.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine,
{\tt NLCreate\-Vector\-With\-Sparse\-Data} allocates and initializes an NLVector data 
structure of a given length and coordinates. The vector returned has {\it nz}
non-zero coordinates, given in the list {\it el} and with values from the 
array {\it vl}. The coordinates may be changed using the {\tt NLVSet\-C} routine 
(page \pageref{Subroutine:NLVSetC}). Zero vectors and vectors with no non-zero
coordinates can be created with the {\tt NLCreate\-Vector} 
(page \pageref{Subroutine:NLCreateVectorWithSparseData})
and 
{\tt NLCreate\-Vector\-With\-Full\-Data} 
(page \pageref{Subroutine:NLCreateVectorWithFullData})
subroutines.

Note that the coordinates and values are copied out of the arrays,
so subsequent changes to the {\it el} and {\it vl} arrays do not effect the
vector.

The NLVector data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Vector} subroutine 
(page \pageref{Subroutine:NLFreeVector}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Vector} subroutine (page 
\pageref{Subroutine:NLRefVector}).
\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return a vector with no nonzero coordinates.
Severity 12 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Length of Vector \%d (argument 1) is Illegal. Must be positive."}&12\\
\parbox[t]{\ERRORMSG}{"Number of nonzeros in vector \%d (argument 2) is Illegal. Must be nonnegative."}&12\\
\parbox[t]{\ERRORMSG}{"The pointer to the array of nonZeros (argument 3) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"The pointer to the array of coordinates (argument 4) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateVectorWithFullData}
\label{Subroutine:NLCreateVectorWithFullData}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLVector data structure of a given length.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLCreateVectorWithFullData({\it n},{\it vl});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The length of the vector.}\\
\tt double& *\it vl &\parbox[t]{\SYNTAX}{The values of the coordinates.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
This routine, {\tt NLCreate\-Vector\-With\-Full\-Data} returns an 
NLVector data structure of a given length and coordinates. The vector 
returned has all coordinates marked as non-zero. 

The coordinates may be changed using the {\tt NLVSet\-C} routine 
(page \pageref{Subroutine:NLVSetC}). Zero vectors and sparse vectors
can be created with the {\tt NLCreate\-Vector} (page 
\pageref{Subroutine:NLCreateVector}) and 
{\tt NLCreate\-Vector\-With\-Sparse\-Data} (page 
\pageref{Subroutine:NLCreateVectorWithSparseData}) subroutines.

Note that the coordinates and values are copied out of the {\it vl} array,
so subsequent changes to it do not effect the vector.

The NLVector data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Vector} subroutine 
(page \pageref{Subroutine:NLFreeVector}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Vector} subroutine (page 
\pageref{Subroutine:NLRefVector}).
\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return a vector with no nonzero coordinates.
Severity 12 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Length of Vector \%d (argument 1) is Illegal. Must be positive."}&12\\
\parbox[t]{\ERRORMSG}{"The pointer to the array of coordinates (argument 2) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
NLVector NLCreateDenseWrappedVector(int n,double *data)
\newpage
\leftline{\bf NLCreateDenseWrappedVector}
\label{Subroutine:NLCreateDenseWrappedVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLVector data structure of a given length with data at a given storage 
location.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLCreateDenseWrappedVector({\it n}, {\it data});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The length of the vector.}\\
\tt double*&\it data &\parbox[t]{\SYNTAX}{The buffer for the coordinates of the vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-DenseWrappedVector} allocates an NLVector data structure and sets
the coordinates to reference a given buffer. The coordinates
may be changed with the {\tt NLVSet\-C} routine (page 
\pageref{Subroutine:NLVSetC}) or by changing the buffer. 

The NLVector data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Vector} subroutine 
(page \pageref{Subroutine:NLFreeVector}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Vector} subroutine (page 
\pageref{Subroutine:NLRefVector}).
\vskip .1in
\leftline{\bf Errors}
Severity 12 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Length of Vector \%d (argument 1) is Illegal. Must be positive."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLFreeVector}
\label{Subroutine:NLFreeVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLVector data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeVector({\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector &\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLVector data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero. References may be added using the {\tt NLRef\-Vector} 
subroutine (page \pageref{Subroutine:NLRefVector}).\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return without changing the vector.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLRefVector}
\label{Subroutine:NLRefVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLVector data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefVector({\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector &\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLVector data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Vector} subroutine (page \pageref{Subroutine:NLFreeVector})
is used to delete the vector, and is only used once per added reference.\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return without changing the vector.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLPrintVector}
\label{Subroutine:NLPrintVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Prints an NLVector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLPrintVector({\it fid},{\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt FILE &*{\it fid}&\parbox[t]{\SYNTAX}{The output file.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLPrint\-Vector} prints an NLVector. The output presents
the vector as a dense vector. Long vectors print the first and last few coordinates.
\vskip .1in
\leftline{\bf Errors}
Errors return without printing the vector.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"File pointer (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Vector (argument 2) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLVGetNC}
\label{Subroutine:NLVGetNC}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the dimension (the number of coordinates) of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLVGetNC({\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of non-zero coordinates.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the dimension, length or number of coordinates of a 
vector. This is set when the vector is created.
\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVGetC}
\label{Subroutine:NLVGetC}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns a coordinate of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLVGetC({\it v},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it c &\parbox[t]{\SYNTAX}{The value of the coordinate.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which coordinate to return.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of a coordinate of a 
vector. The index {\it i} must be nonnegative and less than the 
number of coordinates ({\tt NLVGet\-NC}).\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return a DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVSetC}
\label{Subroutine:NLVSetC}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the specified coordinate of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLVSetC({\it v},{\it i},{\it c});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which coordinate to return.}\\
\tt double&\it c &\parbox[t]{\SYNTAX}{The value of the coordinate.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the value of a coordinate of a 
vector. The index {\it i} must be nonnegative and less than the 
number of coordinates ({\tt NLVGet\-NC}). If the coordinate is not currently
set, it is added to the list of coordinates.\vskip .1in
\leftline{\bf Errors}
Errors return a 0, normal execution returns 1. Errors return without changing the vector.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&4\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCopyVector}
\label{Subroutine:NLCopyVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns a copy of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it v}=NLCopyVector({\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The copy.}\\
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns a copy of a vector. The copy is of the same type
(dense/sparse) as the original, and has the same value.
\leftline{\bf Errors}
Severity 4 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVSetToZero}
\label{Subroutine:NLVSetToZero}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets a vector to zero.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLVSetToZero({\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets all coordinates of a vector to zero.
\leftline{\bf Errors}
Severity 4 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVIncrementC}
\label{Subroutine:NLVIncrementC}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Increments a coordinate of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLVIncrementC({\it u},{\it i},{\it vl});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc&\parbox[t]{\SYNTAX}{The return code. 1 indicates success.}\\
\tt NLVector&\it u&\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i&\parbox[t]{\SYNTAX}{The coordinate to increment.}\\
\tt double&\it vl&\parbox[t]{\SYNTAX}{The amount to add to the coodinate.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a value to a coordinate of a vector.
\leftline{\bf Errors}
Severity 4 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&4\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLVInnerProd}
\label{Subroutine:NLVInnerProd}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the inner product (Euclidean) of two vectors.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it p}=NLVInnerProd({\it u},{\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it p &\parbox[t]{\SYNTAX}{The inner product.}\\
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The first vector.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The second vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the Euclidean inner product of two vectors.
\leftline{\bf Errors}
Severity 4 errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 2) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVPlusV}
\label{Subroutine:NLVPlusV}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the sum of two vectors (actually the daxpy).
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it p}=NLVPlusV({\it u},{\it v},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The first vector.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The second vector.}\\
\tt double&\it a &\parbox[t]{\SYNTAX}{The multiplication factor.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets $u=u+a*v$.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 2) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLNegateVector}
\label{Subroutine:NLNegateVector}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets a vector to it's product with -1.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLNegateVector({\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This sets a vector to its negative.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVSparse}
\label{Subroutine:NLVSparse}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries if a vector is sparse.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it flag}=NLVSparse({\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it flag &\parbox[t]{\SYNTAX}{The answer. 1 indicates sparse, 0 dense}\\
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns 1 if the vector is a sparse vector (otherwise returns 0).
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVnNonZeros}
\label{Subroutine:NLVnNonZeros}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent For a sparse vector returns a pointer to the array containing the list of nonzeros.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLVnNonZeros({\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int*&\it c &\parbox[t]{\SYNTAX}{The list of which coordinates are nonzero.}\\
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns a pointer to the array of which coordinates of a vector are nonzero if the vector is
a sparse vector
(otherwise returns (int*)NULL). Note that this array may be reallocated when a coordinate becomes 
nonzero. In that case the pointer is no longer valid and should not be used (get a new pointer!).
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVnonZero}
\label{Subroutine:NLVnonZero}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent For a sparse vector returns a pointer to the array containing the list of nonzeros.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLVnonZero({\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int*&\it c &\parbox[t]{\SYNTAX}{The list of which coordinates are nonzero.}\\
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns a pointer to the array of which coordinates of a vector are nonzero if the vector is
a sparse vector
(otherwise returns (int*)NULL). Note that this array may be reallocated when a coordinate becomes 
nonzero. In that case the pointer is no longer valid and should not be used (get a new pointer!).
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVGetNumberOfNonZeros}
\label{Subroutine:NLVGetNumberOfNonZeros}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of nonzeros (if sparse) or the number of coordinates (if dense).
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLVGetNumberOfNonZeros({\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The answer.}\\
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of nonzeros if the vector is a sparse vector (otherwise returns the total
umber of coordinates).
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVGetNonZeroCoord}
\label{Subroutine:NLVGetNonZeroCoord}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the requested nonZero (counting only nonzeros for sparse vectors).
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLVGetNonZeroCoord({\it u},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it c &\parbox[t]{\SYNTAX}{The value of the coordinate.}\\
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The answer.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the ith nonzero if the vector is a sparse vector (otherwise returns the ith coordinate).
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"NonZero Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLVGetNonZero}
\label{Subroutine:NLVGetNonZero}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the coordinate index of a non-zero coordinate in a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=NLVGetNonZero({\it v},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it c &\parbox[t]{\SYNTAX}{The value of the th non-zero coordinate.}\\
\tt NLVector&\it v &\parbox[t]{\SYNTAX}{The vector.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which non-zero coordinate.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of a non-zero coordinate. The argument {\it i}
must be nonnegative and less than the number of non-zero coordinates 
{\tt NLVGetNumber of NonZeros}.\vskip .1in
\leftline{\bf Errors}
Errors return a DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"NonZero Coordinate \%d (argument 2) is illegal. Must be in 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLVWrapped}
\label{Subroutine:NLVWrapped}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries if a vector is wrapped.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it flag}=NLVWrapped({\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it flag &\parbox[t]{\SYNTAX}{The answer. 1 indicates wrapped, 0 dense}\\
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns 1 if the vector is a wrapped vector (otherwise returns 0).
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLVData}
\label{Subroutine:NLVData}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns a pointer to the data array of a vector.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it data}=NLVData({\it u});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it data &\parbox[t]{\SYNTAX}{The data array.}\\
\tt NLVector&\it u &\parbox[t]{\SYNTAX}{The vector.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the data array of a vector. If the vector is sparse this contains the packed nonzeros.
If dense it contains the coordinates.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Vector (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLCreateMatrix}
\label{Subroutine:NLCreateMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLMatrix data structure of a given 
size.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it A}=NLCreateMatrix({\it n},{\it m});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of rows in the matrix.}\\
\tt int&\it m &\parbox[t]{\SYNTAX}{The number of columns in the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Matrix} allocates and initializes an NLMatrix data structure of 
a given size. The matrix returned has all elements zero, until 
they are set with the {\tt NLMSet\-Element} routine (page 
\pageref{Subroutine:NLMSetElement}). The {\tt NLCreate\-Matrix\-With\-Data} 
subroutine (page \pageref{Subroutine:NLCreateMatrixWithData})
can be used to created Matrices with supplied elements.

The NLMatrix data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Matrix} subroutine 
(page \pageref{Subroutine:NLFreeMatrix}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Matrix} subroutine (page 
\pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Number of rows \%d (argument 1) is negative."}&12\\
\parbox[t]{\ERRORMSG}{"Number of columns \%d (argument 2) is negative."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%dx\%d matrix (\%d bytes)"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateMatrixWithData}
\label{Subroutine:NLCreateMatrixWithData}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLMatrix data structure of a given 
size with given elements.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it A}=NLCreateMatrixWithData({\it n},{\it m},{\it aij});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of rows in the matrix.}\\
\tt int&\it m &\parbox[t]{\SYNTAX}{The number of columns in the matrix.}\\
\tt double&*\it aij &\parbox[t]{\SYNTAX}{The entries of the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Matrix} allocates and initializes an NLMatrix data structure of 
a given size with given elements. The elements may be changed later 
with the {\tt NLMSet\-Element} routine (page 
\pageref{Subroutine:NLMSetElement}). Zero Matrices can 
be created with the
{\tt NLCreate\-Matrix} subroutine (page \pageref{Subroutine:NLCreateMatrix}).

The NLMatrix data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Matrix} subroutine 
(page \pageref{Subroutine:NLFreeMatrix}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Matrix} subroutine (page 
\pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Severity 12 errors return (NLMatrix)NULL.
Severity 4 errors return a matrix with all entries zero.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Number of rows (argument 1) is negative \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Number of columns (argument 2) is negative \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Pointer to data (argument 3) is NULL"}&4\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%dx\%d matrix (\%d bytes)"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateSparseMatrix}
\label{Subroutine:NLCreateSparseMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLMatrix data structure of a given 
size.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it A}=NLCreateSparseMatrix({\it n},{\it m});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of rows in the matrix.}\\
\tt int&\it m &\parbox[t]{\SYNTAX}{The number of columns in the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Sparse\-Matrix} allocates and initializes a sparse NLMatrix data structure of a given size. Only the non-zeros are stored.
The matrix returned has all elements zero, until 
they are set with the {\tt NLMSet\-Element} routine (page 
\pageref{Subroutine:NLMSetElement}), or incremented by the {\tt LNMIncrement\-Element} routine (page
\pageref{Subroutine:NLMIncrementElement}).

The NLMatrix data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Matrix} subroutine 
(page \pageref{Subroutine:NLFreeMatrix}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Matrix} subroutine (page 
\pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Number of rows \%d (argument 1) is negative."}&12\\
\parbox[t]{\ERRORMSG}{"Number of columns \%d (argument 2) is negative."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%dx\%d matrix (\%d bytes)"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateWSMPSparseMatrix}
\label{Subroutine:NLCreateWSMPSparseMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes a square NLMatrix data structure of a given 
size. The matrix is stored in sparse format where a list of the column for each
nonzero is stored, contiguous by rows, and ordered from first row to last. An
array is also stored with the index of the beginning of each row in the column array.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it A}=NLCreateWSMPSparseMatrix({\it n});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of rows and columns in the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Matrix} allocates and initializes a square NLMatrix data structure of a given 
size. The matrix is stored in sparse format where a list of the column for each
nonzero is stored, contiguous by rows, and ordered from first row to last. An
array is also stored with the index of the beginning of each row in the column array.
Initially there are no nonzeros. As elements are set with the {\tt NLMSet\-Element} routine (page 
\pageref{Subroutine:NLMSetElement}), new nonzeros are added to the matrix.

The NLMatrix data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Matrix} subroutine 
(page \pageref{Subroutine:NLFreeMatrix}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Matrix} subroutine (page 
\pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Number of rows \%d (argument 1) is negative."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%dx\%d matrix (\%d bytes)"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateDenseWrappedMatrix}
\label{Subroutine:NLCreateDenseWrappedMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes a dense NLMatrix data structure of a given 
size, with a data array provided. If the user later changes the array the NLMatrix
will see the changes.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it A}=NLCreateDenseWrappedMatrix({\it n},{\it m},{\it data});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of rows in the matrix.}\\
\tt int&\it m &\parbox[t]{\SYNTAX}{The number of columns in the matrix.}\\
\tt double*&\it data&\parbox[t]{\SYNTAX}{The data array.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Dense\-Wrapped\-Matrix} allocates and initializes an NLMatrix data structure of 
a given size. The matrix returned has the data array specified.

The NLMatrix data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Matrix} subroutine 
(page \pageref{Subroutine:NLFreeMatrix}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Matrix} subroutine (page 
\pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Number of rows \%d (argument 1) is negative."}&12\\
\parbox[t]{\ERRORMSG}{"Number of columns \%d (argument 2) is negative."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefMatrix}
\label{Subroutine:NLRefMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLMatrix data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefMatrix({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLMatrix data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Matrix} subroutine (page \pageref{Subroutine:NLFreeMatrix})
is used to delete the vector, and is only used once per added reference.
\vskip .1in
\leftline{\bf Errors}
Error returns without changing the matrix.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLFreeMatrix}
\label{Subroutine:NLFreeMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLMatrix data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeMatrix({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLMatrix data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero. References may be added using the {\tt NLRef\-Matrix} 
subroutine (page \pageref{Subroutine:NLRefMatrix}).\vskip .1in
\leftline{\bf Errors}
Error returns without changing the matrix.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLMGetNumberOfRows}
\label{Subroutine:NLMGetNumberOfRows}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of rows in an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLMGetNumberOfRows({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of rows.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of rows in the matrix. This is set 
when the matrix is created.
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMGetNumberOfCols}
\label{Subroutine:NLMGetNumberOfCols}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of columns in an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it m}=NLMGetNumberOfCols({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it m &\parbox[t]{\SYNTAX}{The number of columns.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of columns in the matrix. This is set 
when the matrix is created.
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMGetElement}
\label{Subroutine:NLMGetElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns an element of an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it aij}=NLMGetElement({\it A},{\it i},{\it j});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it aij &\parbox[t]{\SYNTAX}{The element of the matrix.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The row index of the element.}\\
\tt int &\it j &\parbox[t]{\SYNTAX}{The column index of the element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the specified element of the matrix. This is set 
when the matrix is created, or with the {\tt NLMSet\-Element} routine
(page \pageref{Subroutine:NLMSetElement}).\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Row index \%d (argument 2) is negative."}&12\\
\parbox[t]{\ERRORMSG}{"Row index \%d (argument 2) is too large. Must be less than \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Column index \%d (argument 3) is negative".}&12\\
\parbox[t]{\ERRORMSG}{"Column index \%d (argument 3) is too large. Must be less than \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMSetElement}
\label{Subroutine:NLMSetElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Changes the value of an element of an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLMSetElement({\it A},{\it i},{\it j},{\it aij});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The row index of the element.}\\
\tt int &\it j &\parbox[t]{\SYNTAX}{The column index of the element.}\\
\tt double &\it aij &\parbox[t]{\SYNTAX}{The element of the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the specified element of the matrix.\vskip .1in
\leftline{\bf Errors}
Errors return 0, with no changes to the matrix. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Row index \%d (argument 2) is negative."}&12\\
\parbox[t]{\ERRORMSG}{"Row index \%d (argument 2) is too large. Must be less than \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Column index \%d (argument 3) is negative".}&12\\
\parbox[t]{\ERRORMSG}{"Column index \%d (argument 3) is too large. Must be less than \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMIncrementElement}
\label{Subroutine:NLMIncrementElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Increments the value of an element of an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLMIncrementElement({\it A},{\it i},{\it j},{\it aij});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The row index of the element.}\\
\tt int &\it j &\parbox[t]{\SYNTAX}{The column index of the element.}\\
\tt double &\it aij &\parbox[t]{\SYNTAX}{The increment element of the matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the specified element of the matrix, by adding the
specified increment. If the matrix is sparse, and the element does not have
a value, the value is set to the increment.\vskip .1in
\leftline{\bf Errors}
Errors return 0, with no changes to the matrix. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Row index \%d (argument 2) is negative."}&12\\
\parbox[t]{\ERRORMSG}{"Row index \%d (argument 2) is too large. Must be less than \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Column index \%d (argument 3) is negative".}&12\\
\parbox[t]{\ERRORMSG}{"Column index \%d (argument 3) is too large. Must be less than \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMatrixDoubleProduct}
\label{Subroutine:NLMatrixDoubleProduct}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Computes the product $u^TAv$.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it p}=NLMatrixDoubleProduct({\it u},{\it A},{\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it p &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLVector &\it u &\parbox[t]{\SYNTAX}{The vector operating on the left.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt NLVector &\it v &\parbox[t]{\SYNTAX}{The vector operating on the right.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the product $u^TAv$. If $A$ is an $n\times m$ matrix $v$ must be an $m$-vector and 
$u$ must be an $n$-vector.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"left vector (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Matrix (argument 2) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"right vector (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Cannot find $u^TAv$ for a \%d vector a \%dx\%d matrix and a \%d vector."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMVMult}
\label{Subroutine:NLMVMult}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Computes the product $b=Ax$.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLMVMult({\it A},{\it x},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt double* &\it x &\parbox[t]{\SYNTAX}{An array containing the coordinates of the vector x.}\\
\tt double* &\it b &\parbox[t]{\SYNTAX}{An array for the result.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the product $b=Ax$. If $A$ is an $n\times m$ matrix $x$ must be an array 
of length $m$, and $b$ must be an array of length $n$.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"A (first argument) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"x (second argument) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"b (third argument) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMVMultT}
\label{Subroutine:NLMVMultT}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Computes the product $b=A^Tx$.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLMVMultT({\it A},{\it x},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt double* &\it x &\parbox[t]{\SYNTAX}{An array containing the coordinates of the vector x.}\\
\tt double* &\it b &\parbox[t]{\SYNTAX}{An array for the result.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the product $b=A^Tx$. If $A$ is an $n\times m$ matrix $x$ must be an array 
of length $n$, and $b$ must be an array of length $m$.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"A (first argument) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"x (second argument) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"b (third argument) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMSetToZero}
\label{Subroutine:NLMSetToZero}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets all elements of an NLMatrix to zero.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLMSetToZero({\it A},{\it i},{\it j},{\it aij});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code. (1 indicates success)}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets all elements of a matrix to zero. For sparse matrices the nonzero structure is not changed, even
though the element values are set to zero.
\leftline{\bf Errors}
Errors return 0, with no changes to the matrix. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMatrixClone}
\label{Subroutine:NLMatrixClone}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Creates a matrix of the same type and size of another, with the same element values.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it B}=NLMatrixClone({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it B &\parbox[t]{\SYNTAX}{The clone.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine creates a new matrix with a deep copy (i.e. new element arrays are allocated and the values
copied). The result is a matrix of the same type as the original.
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLGetGershgorinBounds}
\label{Subroutine:NLGetGershgorinBounds}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Computes bounds (using Gershgorin disks) of the leftmost eigenvalue of a matrix
(with an optional diagonal scaling).
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLGetGershgorinBounds({\it A},{\it M},{\it L},{\it U});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt double* &\it M &\parbox[t]{\SYNTAX}{The vector giving the diagonal scaling.}\\
\tt double* &\it L &\parbox[t]{\SYNTAX}{A double to hold the lower bound.}\\
\tt double* &\it U &\parbox[t]{\SYNTAX}{A double to hold the upper bound.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine provides bounds for the leftmost eigenvalue of the matrix. If the diagonal scaling $M$ is 
not null the matrix is scaled by ${\rm diag}(1./sqrt{M})A{\rm diag}(1./sqrt{M})$. The method is simply
to use the Gershgorin bounds.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (first argument), is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Address for the lower bound (third argument), is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Address for the upper bound (fourth argument), is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMatrixOneNorm}
\label{Subroutine:NLMatrixOneNorm}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Computes the 1-norm of a matrix (with an optional diagonal scaling).
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt $L_1$=NLMatrixOneNorm({\it A},{\it M});}
\vskip .1in
\begin{tabular}{lll}
\tt double &$L_1$ &\parbox[t]{\SYNTAX}{The norm.}\\
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt double* &\it M &\parbox[t]{\SYNTAX}{The vector giving the diagonal scaling.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the one norm of the matrix. If the diagonal scaling $M$ is 
not null the matrix is scaled by ${\rm diag}(1./sqrt{M})A{\rm diag}(1./sqrt{M})$.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (first argument), is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMSumSubMatrixInto}
\label{Subroutine:NLMSumSubMatrixInto}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a sub-matrix with a symmetric non-zero structure into a matrix $A=A+s*a$.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLMSumSubMatrixInto({\it A},{\it s},{\it n},{\it r},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt double &\it s &\parbox[t]{\SYNTAX}{A scale factor.}\\
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of rows/columns of the submatrix.}\\
\tt int* &\it r &\parbox[t]{\SYNTAX}{A vector of length {\it n} giving the rows/columns of the submatrix.}\\
\tt double* &\it a &\parbox[t]{\SYNTAX}{An $n\times n$ matrix giving the elements of the submatrix (stored by columne -- $a_{ij}=a[i+n*j]$).}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a submatrix (with symmetric non-zero structure) into a matrix. That is,
\begin{displaymath}
A_{r[i],r[j]} = A_{r[i],r[j]} + s*a_{i,j}
\end{displaymath}
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (first argument), is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Array of row indices (fourth argument), is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Array of submatrix elements (fifth argument), is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMSumRankOneInto}
\label{Subroutine:NLMSumRankOneInto}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds a rank one matrix into a matrix $A=A+s*v v^T$.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLMSumRankOneInto({\it A},{\it s},{\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\tt double &\it s &\parbox[t]{\SYNTAX}{A scale factor.}\\
\tt double* &\it v &\parbox[t]{\SYNTAX}{An array of length $n$ giving the elements of the vector.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a submatrix (with symmetric non-zero structure) into a matrix. That is,
\begin{displaymath}
A_{i,j} = A_{i,j} + s*v_{i}v_{j}
\end{displaymath}
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (first argument), is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Vector (third argument), is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMMMMProd}
\label{Subroutine:NLMMMMProd}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Computes the matrix-matrix-matrix product $B=M^TAM$.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLMMMMProd({\it A},{\it M},{\it B});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix &\it A &\parbox[t]{\SYNTAX}{An $n\times n$ matrix.}\\
\tt double* &\it M &\parbox[t]{\SYNTAX}{An array containing the dense matrix M (stored by column
-- $M_{ij}=M[i+n*j])$.}\\
\tt double* &\it v &\parbox[t]{\SYNTAX}{An array of length $n*n$ for the result (will be stored by column
-- $B_{ij}=B[i+n*j])$.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine computes the matrix-matrix-matrix product
\begin{displaymath}
B_{i,j} = \sum_k \sum_l M_{i,k}A_{k,l}M_{l,j}
\end{displaymath}
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (first argument), is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Matrix (second argument), is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Result (third argument), is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMSparse}
\label{Subroutine:NLMSparse}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries if a matrix is sparse.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it flag}=NLMSparse({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it flag &\parbox[t]{\SYNTAX}{The answer. 0 indicates dense, 1 sparse stored by row and column index,
2 WSMP format.}\\
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns 0 if the matrix is a dense matrix. If it is stored by row and column index a "1" is 
returned and the matrix is represented by arrays {\it int *row}, {\it int *col} and {\it double *data} so that
\begin{displaymath}
A_{row[i],col[i]} = data[i]
\end{displaymath}
If the matrix is stored in ``WSMP format'', i.e. as a set of sparse rows, this routine returns a "2". In this
case the same three arraies are used, but each non-zero has an entry in the {\it col} array, and the {\it row}
array indicates where in each row begins in the {\it col} array. That is, if $0\leq l<n$  is such that
\begin{displaymath}
row[l]\leq i < row[l+1]
\end{displaymath}
then
\begin{displaymath}
A_{row[l],col[i]}=data[i]
\end{displaymath}
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLMDetermineHessianSparsityStructure}
\label{Subroutine:NLMDetermineHessianSparsityStructure}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Updates the sparsity structure of a matrix to accomodate the nonzeros in
the Hessian of the objective or a constraint of a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt NLMDetermineHessianSparsityStructure({\it P},{\it type},{\it c},{\it H});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt char&\it type &\parbox[t]{\SYNTAX}{Which Hessian to update -- 'O' objective, 'I' inequality constraint,
'E' equality constraint.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which constraint (if type is not 'O').}\\
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The Hessian (the user is responible for allocating this).}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine updates the sparsity structure of a matrix to accomodate the nonzeros in
the Hessian of the objective or a constraint of a problem.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (first argument), is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"type \%c (second argument), is not valid. Must be 'O', 'I', 'E', or 'M'"}&12\\
\parbox[t]{\ERRORMSG}{"Hessian (fourth argument), is NULL."}&12\\
\end{tabular}
\newpage
\leftline{\bf NLMData}
\label{Subroutine:NLMData}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns a pointer to the data array of the matrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it data}=NLMData({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt double*&\it data &\parbox[t]{\SYNTAX}{The data array.}\\
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns a pointer to the internal data array. The contents of the array varies according to 
the sparsity structure (see the NLMSparse routine on page \pageref{Subroutine:NLMSparse} for a description
of the uses of the array).
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLMnE}
\label{Subroutine:NLMnE}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of ``nonzero'' entries in a matrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it nE}=NLMnE({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt double*&\it nE &\parbox[t]{\SYNTAX}{The number of nonzeros.}\\
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
Thiis routine returns the number of ``nonzero'' entries in a matrix. Note that this is the number of 
possible nonzeros, not the number of actual nonzeros. So for an $n\times m$ matrix stored as a 
dense matrix the result is always $n*m$. For matrices stored in one of the sparse formats it is the
number of allocated nonzeros.
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLMRow}
\label{Subroutine:NLMRow}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns a pointer to the ``row'' array of the matrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it row}=NLMRow({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt double*&\it row &\parbox[t]{\SYNTAX}{The row array.}\\
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns a pointer to the internal ``row'' array. The contents of the array varies according to 
the sparsity structure (see the NLMSparse routine on page \pageref{Subroutine:NLMSparse} for a description
of the uses of the array).
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLMCol}
\label{Subroutine:NLMCol}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns a pointer to the ``col'' array of the matrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it col}=NLMCol({\it A});}
\vskip .1in
\begin{tabular}{lll}
\tt double*&\it col &\parbox[t]{\SYNTAX}{The col array.}\\
\tt NLMatrix&\it A &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns a pointer to the internal ``col'' array. The contents of the array varies according to 
the sparsity structure (see the NLMSparse routine on page \pageref{Subroutine:NLMSparse} for a description
of the uses of the array).
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Matrix (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLPrintMatrix}
\label{Subroutine:NLPrintMatrix}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Prints an NLMatrix.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLPrintMatrix({\it fid},{\it v});}
\vskip .1in
\begin{tabular}{lll}
\tt FILE &*{\it fid}&\parbox[t]{\SYNTAX}{The output file.}\\
\tt NLMatrix&\it v &\parbox[t]{\SYNTAX}{The matrix.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLPrint\-Matrix} prints an NLMatrix. The output presents
the matrix as a dense matrix. Large matrices print the whole thing, so
watch out!
\vskip .1in
\leftline{\bf Errors}
Errors return without printing the matrix.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"File pointer (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Matrix (argument 2) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateGroupFunctionByString}
\label{Subroutine:NLCreateGroupFunctionByString}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLGroupFunction data structure by way of an expression.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it G}=NLCreateGroupFunctionByString({\it P},{\it type},{\it var},{\it expr});}
\vskip .1in
\begin{tabular}{lll}
\tt NLGroupFunction \it G &\parbox[t]{\SYNTAX}{The group function.}\\
\tt NLProblem \it P &\parbox[t]{\SYNTAX}{The problem to which the group function belongs.}\\
\tt char *\it type &\parbox[t]{\SYNTAX}{A name associated to the group function.}\\
\tt char *\it var &\parbox[t]{\SYNTAX}{The identifer used in the expression for the argument of the group function.}\\
\tt char *\it expr &\parbox[t]{\SYNTAX}{An expression for the group function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Group\-Function\-By\-String} allocates and initializes an NLGroupFunction data structure.
The {\it var} string (e.g. "s" or "[s]") gives the identifier used in the expression string (e.g. "sin(s)")
for the argument of the group function.

The NLGroupFunction data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Group\-Function} subroutine 
(page \pageref{Subroutine:NLFreeGroupFunction}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Group\-Function} subroutine (page 
\pageref{Subroutine:NLRefGroupFunction}).
\vskip .1in
\leftline{\bf Errors}
Errors return (NLGroupFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"type (argument 2) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"var (argument 3) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"expr (argument 4) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateGroupFunction}
\label{Subroutine:NLCreateGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLGroupFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it G}=NLCreateGroupFunction({\it P},{\it type},{\it g},{\it dg},{\it ddg},{\it data},{\it freeData});}
\vskip .1in
\begin{tabular}{lll}
\tt NLGroupFunction \it G &\parbox[t]{\SYNTAX}{The group function.}\\
\tt NLProblem \it P &\parbox[t]{\SYNTAX}{The problem to which the group function belongs.}\\
\tt char *\it type &\parbox[t]{\SYNTAX}{A name associated to the group function.}\\
\tt double {\it g}\tt (double,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the function.}\\
\tt double {\it dg}\tt (double,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the derivative of the function.}\\
\tt double {\it ddg}\tt (double,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the second derivative of the function.}\\
\tt void {\it *data}&\parbox[t]{\SYNTAX}{A pointer to user specific data which is to be provided to the function.}\\
\tt void {\it (*freeData)(void*)}&\parbox[t]{\SYNTAX}{A pointer to a routine to free user specific data, or (void (*)(void*)NULL). Will be called when the element function is deleted.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Group\-Function} allocates and initializes an NLGroupFunction data structure.

The NLGroupFunction data structure uses reference counting.
The data structure should be deleted using the {\tt NLFree\-Group\-Function} subroutine 
(page \pageref{Subroutine:NLFreeGroupFunction}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRef\-Group\-Function} subroutine (page 
\pageref{Subroutine:NLRefGroupFunction}).
\vskip .1in
\leftline{\bf Errors}
Errors return (NLGroupFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefGroupFunction}
\label{Subroutine:NLRefGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLGroupFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefGroupFunction({\it G});}
\vskip .1in
\begin{tabular}{lll}
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLGroupFunction data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Group\-Function} subroutine (page \pageref{Subroutine:NLFreeGroupFunction})
is used to delete the vector, and is only used once per added reference.
\vskip .1in
\leftline{\bf Errors}
Errors return without changing the group function.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Group Function (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLFreeGroupFunction}
\label{Subroutine:NLFreeGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLGroupFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeGroupFunction({\it G});}
\vskip .1in
\begin{tabular}{lll}
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLGroupFunction data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero. The {\tt NLRef\-Group\-Function} 
subroutine (page \pageref{Subroutine:NLRefGroupFunction})
may be used to add references.
\vskip .1in
\leftline{\bf Errors}
Errors return with changing the group function.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Group Function (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLGEval}
\label{Subroutine:NLGEval}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates an NLGroupFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLGEval({\it G},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it g &\parbox[t]{\SYNTAX}{The value of the group function.}\\
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\tt double &\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of a group function $g(x)$.
\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Group Function (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group Function function is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLGEvalDer}
\label{Subroutine:NLGEvalDer}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the derivative of an NLGroupFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLGEvalDer({\it G},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it g &\parbox[t]{\SYNTAX}{The value of the derivative.}\\
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\tt double &\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of the derivative of a group function ${\rm d}g(x)/{\rm dx}$.
\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Group Function (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group Function Derivative function is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLGEvalSecDer}
\label{Subroutine:NLGEvalSecDer}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the second derivative of an NLGroupFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLGEvalSecDer({\it G},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it g &\parbox[t]{\SYNTAX}{The value of the second derivative.}\\
\tt NLGroupFunction &\it G &\parbox[t]{\SYNTAX}{The group function.}\\
\tt double &\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of the second derivative of a group function ${\rm d}g(x)/{\rm dx}$.
\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}
Message&Severity\\
\hline
\parbox[t]{\ERRORMSG}{"Group Function (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group Function Second Derivative function is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateElementFunctionByString}
\label{Subroutine:NLCreateElementFunctionByString}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLElementFunction data structure by means of an expression.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it F}=NLCreateElementFunctionByString({\it P},{\it type},{\it n},{\it R},{\it vars},{\it expr});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction \it F&\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char *\it type&\parbox[t]{\SYNTAX}{The type given to the new element function.}\\
\tt int {\it n}&\parbox[t]{\SYNTAX}{The number of element variables.}\\
\tt NLMatrix {\it R}&\parbox[t]{\SYNTAX}{The range transformation, or (NLMatrix)NULL if the identity.}\\
\tt char *\it vars&\parbox[t]{\SYNTAX}{A ``[]`` delimited, comma separated list of the identifiers
used in the expression for the internal variables of the element function.}\\
\tt char *\it expr&\parbox[t]{\SYNTAX}{An expression giving the element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreateElementFunctionByString} allocates and initializes an NLElementFunction data structure. The
{\it vars} string (e.g. "[x,y,z]") gives a list of the identifiers used in the expression for the 
internal variables of the element. The range transformation {\it R} is used to map from element variables
(a subset of the problem variables) to internal variables. The order in the {\it vars} string is the
order in the vector produced by the range transformation.

The NLElementFunction data structure uses reference counting.
The data structure should be deleted using the {\tt NLFreeElementFunction} subroutine 
(page \pageref{Subroutine:NLFreeElementFunction}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRefElementFunction} subroutine (page 
\pageref{Subroutine:NLRefElementFunction}).
\vskip .1in
\leftline{\bf Errors}
Errors return (NLElementFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"type (argument 2) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"vars (argument 5) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"expr (argument 6) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"Number of coordinates is not positive \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateElementFunction}
\label{Subroutine:NLCreateElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLElementFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
NLElementFunction NLCreateElementFunction(NLProblem P,char *type,int n,NLMatrix
R,double (*f)(int,double*,void*),double (*df)(int,int,double*,void*),double (*dd
f)(int,int,int,double*,void*),void *data,void (*freedata)(void*));

\leftline{\tt {\it F}=NLCreateElementFunction({\it P},{\it type},{\it n},{\it R},{\it f},{\it df},{\it ddf},{\it data}{\it freeData});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction \it F&\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char *\it type&\parbox[t]{\SYNTAX}{The type given to the new element function.}\\
\tt int {\it n}&\parbox[t]{\SYNTAX}{The number of element variables.}\\
\tt NLMatrix {\it R}&\parbox[t]{\SYNTAX}{The range transformation, or (NLMatrix)NULL if the identity.}\\
\tt double {\it f}\tt (int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the function.}\\
\tt double {\it df}\tt (int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the derivative of the function.}\\
\tt double {\it ddf}\tt (int,int,int,double*,void*)&\parbox[t]{\SYNTAX}{The routine giving the value of the second derivative of the function.}\\
\tt void {\it *data}&\parbox[t]{\SYNTAX}{A pointer to user specific data which will be passed to the function.}\\
\tt void {\it (*freeData)(void*)}&\parbox[t]{\SYNTAX}{A pointer to a routine to free user specific data, or (void (*)(void*)NULL). Will be called when the element function is deleted.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreateElementFunction} allocates and initializes an NLElementFunction data structure.

The NLElementFunction data structure uses reference counting.
The data structure should be deleted using the {\tt NLFreeElementFunction} subroutine 
(page \pageref{Subroutine:NLFreeElementFunction}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRefElementFunction} subroutine (page 
\pageref{Subroutine:NLRefElementFunction}).
\vskip .1in
\leftline{\bf Errors}
Errors return (NLElementFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"Number of coordinates is not positive \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefElementFunction}
\label{Subroutine:NLRefElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLElementFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefElementFunction({\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLElementFunction data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Element\-Function} subroutine (page \pageref{Subroutine:NLFreeElementFunction})
is used to delete the vector, and is only used once per added reference.
\vskip .1in
\leftline{\bf Errors}
Errors return without chaning the element function.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Element Function (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLFreeElementFunction}
\label{Subroutine:NLFreeElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLElementFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeElementFunction({\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLElementFunction data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero.  The {\tt NLRef\-Element\-Function} 
subroutine (page \pageref{Subroutine:NLRefElementFunction})
may be used to add References.
\vskip .1in
\leftline{\bf Errors}
Errors return without chaning the element function.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Element Function (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLEGetDimension}
\label{Subroutine:NLEGetDimension}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of unknowns (element internal variables) for an NLElementFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLEGetDimension({\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of unknowns.}\\
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of unknowns for an element function.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Element Function (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLEEval}
\label{Subroutine:NLEEval}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates an NLElementFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLEEval({\it F},{\it n},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it f &\parbox[t]{\SYNTAX}{The value of the element function.}\\
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of coordinates.}\\
\tt double &*\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of a element function $f(x)$.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Element Function (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Number of arguments to Element Function \%d is illegal (argument 2). Must be \%d. Argument 1 is \%8.8x"}&12\\
\parbox[t]{\ERRORMSG}{"Pointer to x (argument 3) is NULL. F is \%8.8x"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLEEvalDer}
\label{Subroutine:NLEEvalDer}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the derivative of an NLElementFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLEEvalDer({\it F},{\it i},{\it n},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it f &\parbox[t]{\SYNTAX}{The value of the derivative.}\\
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The first variable.}\\
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of coordinates in the point.}\\
\tt double &*\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of the derivative of a element function ${\rm d}f(x)/{\rm dx_i}$.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Element Function (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Direction \%d (argument 2) is illegal. Must be in range 0 to \%d Argument 1 is \%8.8x"}&12\\
\parbox[t]{\ERRORMSG}{"Number of arguments to Element Function \%d is illegal (argument 3). Must be \%d. Argument 1 is \%8.8x"}&12\\
\parbox[t]{\ERRORMSG}{"Pointer to x (argument 4) is NULL. F is \%8.8x"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLEEvalSecDer}
\label{Subroutine:NLEEvalSecDer}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Evaluates the second derivative of an NLElementFunction.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLEEvalSecDer({\it F},{\it i},{\it j},{\it n},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt double &\it f &\parbox[t]{\SYNTAX}{The value of the second derivative.}\\
\tt NLElementFunction &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The first variable.}\\
\tt int &\it j &\parbox[t]{\SYNTAX}{The second variable.}\\
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of coordinates in the point.}\\
\tt double &*\it x &\parbox[t]{\SYNTAX}{The point.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the value of the second derivative of a element function ${\rm d}^2f(x)/{\rm dx_i}/{\rm dx_j}$.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Element Function (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Direction \%d (argument 2) is illegal. Must be in range 0 to \%d Argument 1 is \%8.8x"}&12\\
\parbox[t]{\ERRORMSG}{"Direction \%d (argument 3) is illegal. Must be in range 0 to \%d Argument 1 is \%8.8x"}&12\\
\parbox[t]{\ERRORMSG}{"Number of arguments to Element Function \%d is illegal (argument 4). Must be \%d. Argument 1 is \%8.8x"}&12\\
\parbox[t]{\ERRORMSG}{"Pointer to x (argument 5) is NULL. F is \%8.8x"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateNonlinearElement}
\label{Subroutine:NLCreateNonlinearElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLElementFunction data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}

\leftline{\tt {\it NE}=NLCreateNonlinearElement({\it P},{\it type},{\it fn},{\it vars});}
\vskip .1in
\begin{tabular}{lll}
\tt NLNonlinearElement\it NE&\parbox[t]{\SYNTAX}{The new nonlinear element.}\\
\tt NLProblem {\it P}&\parbox[t]{\SYNTAX}{The problem.}\\
\tt char *{\it type}&\parbox[t]{\SYNTAX}{The type given to the new nonlinear element.}\\
\tt NLElementFuntion {\it fn}&\parbox[t]{\SYNTAX}{The element function for the new nonlinear element.}\\
\tt int *{\it vars}&\parbox[t]{\SYNTAX}{A list of the element variables for the new nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreateNonlinearElement} allocates and initializes an NLNonlinearElement data structure.

The NLNonlinearElement data structure uses reference counting.
The data structure should be deleted using the {\tt NLFreeNonlinearElement} subroutine 
(page \pageref{Subroutine:NLFreeNonlinearElement}). This will decrement the reference
count and free the storage if the count goes to zero. References may be 
added using the {\tt NLRefNonlinearElement} subroutine (page 
\pageref{Subroutine:NLRefNonlinearElement}).
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"Element Function (argument 3) is NULL."}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefNonlinearElement}
\label{Subroutine:NLRefNonlinearElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLNonlinearElement data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefNonlinearElement({\it P},{\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLNonlinearElement data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Nonlinear\-Element} subroutine (page \pageref{Subroutine:NLFreeNonlinearElement})
is used to delete the vector, and is only used once per added reference.
\vskip .1in
\leftline{\bf Errors}
Errors return without chaning the element function.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Element Function (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLFreeNonlinearElement}
\label{Subroutine:NLFreeNonlinearElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Frees the storage associated with an NLNonlinearElement data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeNonlinearElement({\it P},{\it F});}
\vskip .1in
\begin{tabular}{lll}
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it F &\parbox[t]{\SYNTAX}{The element function.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLNonlinearElement data structure uses reference counting. This routine
should be used to indicate that a vector is no longer needed. It
will decrement the reference count and free the storage if the count 
goes to zero.  The {\tt NLRef\-Nonlinear\-Element} 
subroutine (page \pageref{Subroutine:NLRefNonlinearElement})
may be used to add References.
\vskip .1in
\leftline{\bf Errors}
Errors return without chaning the element function.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Nonlinear Element (argument 2) is invalid, "}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetName}
\label{Subroutine:NLNEGetName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLNEGetName({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt char *&\it name &\parbox[t]{\SYNTAX}{The name.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetElementDimension}
\label{Subroutine:NLNEGetElementDimension}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of element variables for a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLNEGetElementDimension({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of element variables.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of element variables for a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetInternalDimension}
\label{Subroutine:NLNEGetInternalDimension}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of internal variables for a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLNEGetInternalDimension({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it n &\parbox[t]{\SYNTAX}{The number of internal variables.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of internal variables for a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetElementFunction}
\label{Subroutine:NLNEGetElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLNEGetElementFunction({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction &\it f &\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the element function of a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetIndex}
\label{Subroutine:NLNEGetIndex}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of an element variable of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it var}=NLNEGetIndex({\it P},{\it ne},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int &\it var &\parbox[t]{\SYNTAX}{The variable.}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\tt int &\it i &\parbox[t]{\SYNTAX}{The index of the element variable.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of an element variable of a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Nonlinear Element (argument 2) is invalid"}&12\\
\parbox[t]{\ERRORMSG}{"Variable (argument 3) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLNEGetRangeXForm}
\label{Subroutine:NLNEGetRangeXForm}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the range transformation of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLNEGetRangeXForm({\it P},{\it ne});}
\vskip .1in
\begin{tabular}{lll}
\tt LNRangeXForm &\it f &\parbox[t]{\SYNTAX}{The range transformation (NULL if the identity).}\\
\tt NLProblem &\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt NLNonlinearElement &\it ne &\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the range transformation of a nonlinear element.

\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Nonlinear Element (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfNonlinearElements}
\label{Subroutine:NLPGetNumberOfNonlinearElements}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of nonlinear elements.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfNonlinearElements({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int \it n&\parbox[t]{\SYNTAX}{The number of nonlinear elements.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLPGetNumberOfNonlinearElements} returns the number of nonlinear elements.

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfGroups}
\label{Subroutine:NLPGetNumberOfGroups}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of groups in a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfGroups({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of groups.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the current number of groups in a problem. Each time
a group is added to the objective, or a nonlinear constraint is added this
number increases. It never decreases.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetTypeOfGroup}
\label{Subroutine:NLPGetTypeOfGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the type of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it type}=NLPGetTypeOfGroup({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The type of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the group type.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the type of a group. Group types are assigned 
with the {\tt NLPAdd\-Group\-To\-Objective} (page
\pageref{Subroutine:NLPAddGroupToObjective})
subroutine, as the last argument. A new
group is assigned a number, and the name is stored. The type name 
``TRIVIAL GROUP'' is always defined, and is type number 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupTypeName}
\label{Subroutine:NLPGetGroupTypeName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a type of group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetGroupTypeName({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the group type.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the group type.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a type of group. Group types are assigned 
with the {\tt NLPAdd\-Group\-To\-Objective} isubroutine (page
\pageref{Subroutine:NLPAddGroupToObjective}) and similar routines for the constraints.
A new group is assigned a number, and the name is stored. The type name 
``TRIVIAL GROUP'' is always defined, and is type number 0.

Note: The user should not free the returned string.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupName}
\label{Subroutine:NLPGetGroupName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the name of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetGroupName({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The name of the group.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The number of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the name of a group. Group names are assigned 
with the {\tt NLPAdd\-Group\-To\-Objective} (page \pageref{Subroutine:NLPAddGroupToObjective})
subroutine (and the routines for ading groups to the constraints). Group names need to be unique.

Note: The user should not free the returned string.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetGroupFunction}
\label{Subroutine:NLPSetGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the group function of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetGroupFunction({\it P},{\it group},{\it g});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLGroupFunction&\it g&\parbox[t]{\SYNTAX}{The group function.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the group function of a group. This can be queried with
the {\tt NLPGet\-Group\-Function} (page \pageref{Subroutine:NLPGetGroupFunction})
subroutine. The default value is the identity (the trivial group).\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Can't Set Trivial Group's Group Function, group \%d",group}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupFunction}
\label{Subroutine:NLPGetGroupFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the group function of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it g}=NLPGetGroupFunction({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt NLGroupFunction&\it g&\parbox[t]{\SYNTAX}{The group function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the group function of a group. This can be set with
the {\tt NLPSet\-Group\-Function} (page \pageref{Subroutine:NLPSetGroupFunction})
subroutine. The default value is the identity (the trivial group).\vskip .1in
\leftline{\bf Errors}
Errors return (NLGroupFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsGroupFunctionSet}
\label{Subroutine:NLPIsGroupFunctionSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the group function of a group has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsGroupFunctionSet({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine queries the group function of a group. If it has it's default 
value, the trivial group, 0 is returned, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetGroupA}
\label{Subroutine:NLPSetGroupA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the linear part of the linear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetGroupA({\it P},{\it group},{\it a});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of a group. This can
be queried with the {\tt NLPGet\-GroupA} (page \pageref{Subroutine:NLPGetGroupA})
subroutine.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupA}
\label{Subroutine:NLPGetGroupA}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the linear part of the linear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it a}=NLPGetGroupA({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it a&\parbox[t]{\SYNTAX}{The linear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the linear part of the lineear element of a group. This can
be queried with the {\tt NLPGet\-GroupA} (page \pageref{Subroutine:NLPGetGroupA})
subroutine. The default value is the zero vector.

The vector must have as many entires as the number of variables in the problem.
See the {\tt NLCreate\-Vector} (page \pageref{Subroutine:NLCreateVector}),
the {\tt NLCreate\-Vector\-With\-Full\-Data} (page 
\pageref{Subroutine:NLCreateVectorWithFullData}),
and the {\tt NLCreate\-Vector\-With\-Sparse\-Data} (page 
\pageref{Subroutine:NLCreateVectorWithSparseData}) subroutines.\vskip .1in
\leftline{\bf Errors}
Errors return (NLVector)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsGroupASet}
\label{Subroutine:NLPIsGroupASet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the linear part of the linear element of a group has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsGroupASet({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether the linear part of the linear element of a group
has been set.  If it has it's default value, the zero vector, the routine
returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetGroupB}
\label{Subroutine:NLPSetGroupB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the constant part of the linear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetGroupB({\it P},{\it group},{\it b});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt double&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the constant part of the lineear element of a group. 
The default value is zero.

Note: The definition uses a negative sign for the constant that might be counter
intuitive.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupB}
\label{Subroutine:NLPGetGroupB}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the constant part of the linear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it b}=NLPGetGroupB({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt NLVector&\it b&\parbox[t]{\SYNTAX}{The constant.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the constant part of the lineear element of a group. This can
be queried with the {\tt NLPGet\-GroupB} (page \pageref{Subroutine:NLPGetGroupB})
subroutine.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsGroupBSet}
\label{Subroutine:NLPIsGroupBSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the constant part of the linear element of a group has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsGroupBSet({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether the constant part of the linear element of a group
has been set.  If it has it's default value, zero, the routine
returns 0, otherwise 1.

Note: setting the constant part to 0 with {\tt NLPSet\-GroupB} will not result 
in an ``unset'' result.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetGroupScale}
\label{Subroutine:NLPSetGroupScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the scale factor of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetGroupScale({\it P},{\it group},{\it s});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt double&\it s&\parbox[t]{\SYNTAX}{The scale factor.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine sets the scale factor of a group. This can
be queried with the {\tt NLPGet\-Group\-Scale} (page \pageref{Subroutine:NLPGetGroupScale})
subroutine.

Note: The definition uses $1/s$ to multiply the group function.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupScale}
\label{Subroutine:NLPGetGroupScale}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the scale factor of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it s}=NLPGetGroupScale({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it s&\parbox[t]{\SYNTAX}{The scale factor.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the scale factor of a group. This can
be queried with the {\tt NLPGet\-Group\-Scale} (page \pageref{Subroutine:NLPGetGroupScale})
subroutine.

Note: The definition uses $1/s$ to multiply the group function.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPAddNonlinearElementToGroup}
\label{Subroutine:NLPAddNonlinearElementToGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Adds an empty nonlinear element to a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it e}=NLPAddNonlinearElementToGroup({\it P},{\it group},{\it type},{\it weight},{\it f},{\it variables},{\it xfrm});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it e&\parbox[t]{\SYNTAX}{The index of the new nonlinear element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt char&*\it type &\parbox[t]{\SYNTAX}{The type of the new nonlinear element.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt NLElementFunction&\it f &\parbox[t]{\SYNTAX}{The element function or NULL.}\\
\tt int&\*it variables &\parbox[t]{\SYNTAX}{A list of the internal variables.}\\
\tt NLMatrix&\it xfrm &\parbox[t]{\SYNTAX}{The range transformation or NULL.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine adds a nonlinear element to a group. The group may be
either a nonlinear constraint or an objective group.

If the element function passed is {\tt (NLElementFunction)NULL}, it is not set.
If the range transformation passed is {\tt (NLMatrix)NULL}, it is not set.
If a range transformation is given, it must have as many columns as there are
internal variables, and as many rows as the element function has unknowns.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementWeight}
\label{Subroutine:NLPGetElementWeight}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the weight of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it weight}=NLPGetElementWeight({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the weight of a nonlinear element in a group. The group
may be either a nonlinear constraint or an objective group.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetElementWeight}
\label{Subroutine:NLPSetElementWeight}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Changes the weight of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetElementWeight({\it P},{\it group},{\it element},{\it weight});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\tt double&\it weight &\parbox[t]{\SYNTAX}{The weight.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the weight of a nonlinear element in a group. The group
may be either a nonlinear constraint or an objective group.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsElementWeightSet}
\label{Subroutine:NLPIsElementWeightSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the weight of a nonlinear element has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsElementWeightSet({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element &\parbox[t]{\SYNTAX}{The number of the element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether the weight of a nonlinear element of a group
has been set.  If it has not the routine returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementFunctionOfGroup}
\label{Subroutine:NLPGetElementFunctionOfGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the nonlinear element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLPGetElementFunction({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction&\it f&\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the nonlinear element function of an element of a 
group. Note that a global index may also be used, with the
{\tt NLPGet\-Element\-Function} (page \pageref{Subroutine:NLPGetElementFunction})
routine.\vskip .1in
\leftline{\bf Errors}
Errors return (NLElementFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupNonlinearElement}
\label{Subroutine:NLPGetGroupNonlinearElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns a nonlinear element of a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ne}=NLPGetGroupNonlinearElement({\it P},{\it group},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt NLNonlinearElement \it ne&\parbox[t]{\SYNTAX}{The nonlinear element.}\\
\tt NLProblem \it P&\parbox[t]{\SYNTAX}{The problem.}\\
\tt int {\it group}&\parbox[t]{\SYNTAX}{The group.}\\
\tt int {\it i}&\parbox[t]{\SYNTAX}{Which element.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLPGetGroupNonlinearElement} returns a nonlinear element of a group.

\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group (argument 2) is invalid"}&12\\
\parbox[t]{\ERRORMSG}{"Element (argument 3) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementFunction}
\label{Subroutine:NLPGetElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the nonlinear element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLPGetElementFunction({\it P},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt NLElementFunction&\it f&\parbox[t]{\SYNTAX}{The element function.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The index of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the nonlinear element function of an element. Note that a
global index is used, not the numebr of the element in a group. That method
is used by the {\tt NLPGet\-Element\-Function\-Of\-Group} (page 
\pageref{Subroutine:NLPGetElementFunctionOfGroup}) routine.\vskip .1in
\leftline{\bf Errors}
Errors return (NLElementFunction)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetElementFunction}
\label{Subroutine:NLPSetElementFunction}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Changes the nonlinear element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetElementFunction({\it P},{\it group},{\it element},{\it f},{\it variables});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\tt NLElementFunction&\it f &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int&\*it variables &\parbox[t]{\SYNTAX}{A list of the internal variables.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the nonlinear element function of an element of a group.
There must be as many entries in the list of internal variables as the
element function has unknowns.\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPSetElementFunctionWithRange}
\label{Subroutine:NLPSetElementFunctionWithRange}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Changes the nonlinear element function of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=NLPSetElementFunctionWithRange({\it P},{\it group},{\it element},{\it f},{\it variables},{\it xfrm});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\tt NLElementFunction&\it f &\parbox[t]{\SYNTAX}{The element function.}\\
\tt int&\*it variables &\parbox[t]{\SYNTAX}{A list of the internal variables.}\\
\tt NLMatrix&\it xfrm &\parbox[t]{\SYNTAX}{The range transformation.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine changes the nonlinear element function of an element of a group.
There must be as many entries in the list of internal variables as the
element function has unknowns.

The range transformation must have as many columns as there are
internal variables, and as many rows as the element function has unknowns.
\vskip .1in
\leftline{\bf Errors}
Errors return 0 and make no changes to the problem. Normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes",n*sizeof(int)}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPIsElementFunctionSet}
\label{Subroutine:NLPIsElementFunctionSet}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Queries whether the weight of a nonlinear element has been set.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it ans}=NLPIsElementFunctionSet({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it ans&\parbox[t]{\SYNTAX}{The answer, 1==Set, 0=Not Set.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element &\parbox[t]{\SYNTAX}{The number of the element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routines queries whether the element function of a nonlinear element of 
a group has been set.  If it has not the routine returns 0, otherwise 1.

If an error occurs ans will be -1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementRangeTransformationOfGroup}
\label{Subroutine:NLPGetElementRangeTransformationOfGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the range transformation of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it f}=NLPGetElementRangeTransformationOfGroup({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it f&\parbox[t]{\SYNTAX}{The range transformation.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group&\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the range transformation of an element of a 
group. Note that a global index may also be used, with the
{\tt NLPGet\-Element\-Range\-Transformation} (page \pageref{Subroutine:NLPGetElementRangeTransformation})
routine.\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementRangeTransformation}
\label{Subroutine:NLPGetElementRangeTransformation}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the range transformation of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it xfrm}=NLPGetElementRangeTransformation({\it P},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt NLMatrix&\it xfrm &\parbox[t]{\SYNTAX}{The range transformation.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The index of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the range transformation of a nonlinear element in a group.
 Note that a
global index is used, not the numebr of the element in a group. That method
is used by the {\tt NLPGet\-Element\-Range\-Transformation\-Of\-Group} (page
\pageref{Subroutine:NLPGetElementRangeTransformationOfGroup}) routine.
\vskip .1in
\leftline{\bf Errors}
Errors return (NLMatrix)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"The global element index \%d (argument 2) is illegal, must be in range 0 to \%d."}&4\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfInternalVariablesInElement}
\label{Subroutine:NLPGetNumberOfInternalVariablesInElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of internal variables of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetElementNumberOfInternalVariablesInElement({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of internal variables.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of internal variables of a nonlinear element in a group.
The group may be either a nonlinear constraint or an objective group.

Note: this is not the number of unknowns of an element function, since the range
transformation may be applied before the element function is evaluated.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementIndexIntoWhole}
\label{Subroutine:NLPGetElementIndexIntoWhole}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of internal variables of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it var}=NLPGetElementIndexIntoWhole({\it P},{\it group},{\it element},{\it int i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it var &\parbox[t]{\SYNTAX}{The index of the internal variable.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\tt int&\it i&\parbox[t]{\SYNTAX}{Which internal variable.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of an internal variable of a nonlinear element
in a group. The group may be either a nonlinear constraint or an objective 
group.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element Internal Variable index \%d is illegal (argument 4). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementNumberOfUnknowns}
\label{Subroutine:NLPGetElementNumberOfUnknowns}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of unknowns of a nonlinear element function.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetElementNumberOfUnknowns({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of unknowns.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element&\parbox[t]{\SYNTAX}{The number of the nonlinear element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of unknowns of a nonlinear element function
in a group.
The group may be either a nonlinear constraint or an objective group.

Note: this is not the number of internal variables of an element, since the 
range transformation may be applied before the element function is evaluated.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementsInGroup}
\label{Subroutine:NLPGetNumberOfElementsInGroup}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements in a group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementsInGroup({\it P},{\it group});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{Which group.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements in a group.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElements}
\label{Subroutine:NLPGetNumberOfElements}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements for a problem.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElements({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements for a problem.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementsO}
\label{Subroutine:NLPGetNumberOfElementsO}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements in the Objective.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementsiO({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements in the Objective.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementsE}
\label{Subroutine:NLPGetNumberOfElementsE}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements in the equality constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementsE({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements in the equality 
constraints.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementsI}
\label{Subroutine:NLPGetNumberOfElementsI}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the total number of nonlinear elements in the inequality constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementsI({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n&\parbox[t]{\SYNTAX}{The number of elements.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the total number of nonlinear elements in the inequality
constraints.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementTypeName}
\label{Subroutine:NLPGetElementTypeName}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the type name of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it name}=NLPGetElementTypeName({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it name &\parbox[t]{\SYNTAX}{The type name of the element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element &\parbox[t]{\SYNTAX}{The number of the element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the type name of a nonlinear element. Element types are
assigned with the 
{\tt NLCreate\-Nonlinear\-Element} (page \pageref{Subroutine:NLCreateNonlinearElement}) 
subroutine. A new type is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetTypeOfElement}
\label{Subroutine:NLPGetTypeOfElement}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the type name of a nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it type}=LNPTypeOfElement({\it P},{\it group},{\it element});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it type &\parbox[t]{\SYNTAX}{The type of the element.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it group &\parbox[t]{\SYNTAX}{The index of the group.}\\
\tt int&\it element &\parbox[t]{\SYNTAX}{The number of the element.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the type of a nonlinear element. Element types are
assigned with the 
{\tt NLCreate\-Nonlinear\-Element} (page \pageref{Subroutine:NLCreateNonlinearElement}) 
subroutine. A new type name is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Group \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\parbox[t]{\ERRORMSG}{"Element \%d is illegal (argument 3). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfElementTypes}
\label{Subroutine:NLPGetNumberOfElementTypes}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of distinct types of nonlinear elements.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfElementTypes({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of element types.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of distinct element types. Element types are
assigned with the 
{\tt NLCreate\-Nonlinear\-Element} (page \pageref{Subroutine:NLCreateNonlinearElement}) 
subroutine. A new type name is assigned a number, and the 
name is stored.
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetElementType}
\label{Subroutine:NLPGetElementType}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of a type of nonlinear element.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it type}=NLPGetElementType({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it type &\parbox[t]{\SYNTAX}{The index of the element type.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{Which type.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of an element type. Element types are
assigned with the 
{\tt NLCreate\-Nonlinear\-Element} (page \pageref{Subroutine:NLCreateNonlinearElement}) 
subroutine. A new type name is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Element type \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetNumberOfGroupTypes}
\label{Subroutine:NLPGetNumberOfGroupTypes}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the number of distinct types of groups.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it n}=NLPGetNumberOfGroupTypes({\it P});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it n &\parbox[t]{\SYNTAX}{The number of group types.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the number of distinct group types. Group types are
assigned with the 
{\tt NLPAdd\-Group\-To\-Objective} (page \pageref{Subroutine:NLPAddGroupToObjective}) 
subroutine. A new type name is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLPGetGroupType}
\label{Subroutine:NLPGetGroupType}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Returns the index of a type of group.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it type}=NLPGetGroupType({\it P},{\it i});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it type &\parbox[t]{\SYNTAX}{The type.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem.}\\
\tt int&\it i &\parbox[t]{\SYNTAX}{The index of the type.}\\
\end{tabular}
\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
This routine returns the index of a group type. Group types are
assigned with the 
{\tt NLPAdd\-Group\-To\-Objective} (page \pageref{Subroutine:NLPAddGroupToObjective}) 
subroutine. A new type name is assigned a number, and the 
name is stored.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Problem (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Type \%d is illegal (argument 2). Must be in range 0 to \%d"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLCreateLancelot}
\label{Subroutine:NLCreateLancelot}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLLancelot data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it Lan}=NLCreateLancelot();}
\vskip .1in
\begin{tabular}{lll}
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLCreate\-Lancelot} allocates and initializes an NLLancelot data structure.
The solver returned has default parameters values, which 
can be set with various subroutines. Multiple instances are
legal.

The storage used by the solver can be returned to the system
using the {\tt NLFree\-Lancelot} subroutine (page 
\pageref{Subroutine:NLFreeLancelot}).\vskip .1in
\leftline{\bf Errors}
Errors return (NLLancelot)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\end{tabular}
\newpage
\leftline{\bf NLRefLancelot}
\label{Subroutine:NLRefLancelot}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Registers a reference to an NLLancelot data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLRefLancelot({\it lan});}
\vskip .1in
\begin{tabular}{lll}
\tt NLLancelot &\it lan &\parbox[t]{\SYNTAX}{The LANCELOT solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The NLLancelot data structure uses reference counting. This routine
should be used to indicate that a vector is needed by another data 
structure. The vector will not be deleted until the same data
structure indicates that it no longer needed (for example, when the
data structure itself is deleted). This works as long as the 
{\tt NLFree\-Lancelot} subroutine (page \pageref{Subroutine:NLFreeLancelot})
is used to delete the vector, and is only used once per added reference.\vskip .1in
\leftline{\bf Errors}
Severity 4 errors return without changing the vector.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Pointer to Lancelot (argument 1) is NULL"}&4\\
\end{tabular}
\newpage
\leftline{\bf NLFreeLancelot}
\label{Subroutine:NLFreeLancelot}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Releases storage associated with an NLLancelot data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void NLFreeLancelot({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt NLFree\-Lancelot} returns storage associated with a solver to the system.\vskip .1in
\leftline{\bf Errors}
Errors return without changing the solver.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNMinimize}
\label{Subroutine:LNMinimize}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLLancelot data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=LNMinimize({\it Lan},{\it P},{\it x0},{\it z0},{\it l0},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem to be solved.}\\
\tt double&*\it x0 &\parbox[t]{\SYNTAX}{The initial guess.}\\
\tt double&*\it z0 &\parbox[t]{\SYNTAX}{The initial values of the min-max variables (currently only one value), or (double*)NULL.}\\
\tt double&*\it l0 &\parbox[t]{\SYNTAX}{The initial guess at the multipliers, or (double*)NULL.}\\
\tt double&*\it x &\parbox[t]{\SYNTAX}{The solution.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt LNMinimize} invokes Lancelot to find a minimizer
of the objective function of a problem. If there are
min-max constraints the vector containing the inital values 
for the minmax variables should be either NULL (no value), 
or one. The vector containing
the initial Lagrange multipliers should either be NULL (no
values given), or length as long as the total number of constraints,
including min-max constraints). 

Note: the user is responsible for allocating sufficient space for the 
solution.
\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Pointer to initial guess (argument 2) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Pointer to area to store the solution (argument 4) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Error opening file \%s for writing in current directory"}&12\\
\parbox[t]{\ERRORMSG}{"Error closing file \%s"}&4\\
\parbox[t]{\ERRORMSG}{"Error opening file SOLUTION.d for reading in current directory"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNMaximize and LNMaximizeDLL}
\label{Subroutine:LNMaximize}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Allocates and initializes an NLLancelot data structure.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it c}=LNMaximize({\it Lan},{\it P},{\it x0},{\it z0},{\it l0},{\it x});}
\leftline{\tt {\it c}=LNMaximizeDLL({\it Lan},{\it P},{\it x0},{\it z0},{\it l0},{\it x});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt NLProblem&\it P &\parbox[t]{\SYNTAX}{The problem to be solved.}\\
\tt double&*\it x0 &\parbox[t]{\SYNTAX}{The initial guess.}\\
\tt double&*\it z0 &\parbox[t]{\SYNTAX}{The initial value of the min-max variabls, or (double*)NULL.}\\
\tt double&*\it l0 &\parbox[t]{\SYNTAX}{The initial guess at the multipliers, or (double*)NULL.}\\
\tt double&*\it x &\parbox[t]{\SYNTAX}{The solution.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine
{\tt LNMinimize} invokes Lancelot to find a maximizer
of the objective function of a problem. If there are
min-max constraints the vector containing the inital values 
for the minmax variables should be either NULL (no value), 
or one. The vector containing
the initial Lagrange multipliers should either be NULL (no
values given), or length as long as the total number of constraints,
including min-max constraints). 

Note: the user is responsible for allocating sufficient space for the 
solution.
\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Pointer to initial guess (argument 2) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Pointer to area to store the solution (argument 4) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Error opening file \%s for writing in current directory"}&12\\
\parbox[t]{\ERRORMSG}{"Error closing file \%s"}&4\\
\parbox[t]{\ERRORMSG}{"Error opening file SOLUTION.d for reading in current directory"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetCheckDerivatives}
\label{Subroutine:LNSetCheckDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how Lancelot testtests derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetCheckDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it flag &\parbox[t]{\SYNTAX}{How to test.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Check\-Derivatives} 
sets the parameter controlling how Lancelot tests derivatives.
Legal values for the flag and their meaning --
\begin{center}
\begin{tabular}{ll}
0&No checking\\
1&Check all derivatives\\
2&Check derivatives\\
3&Check element derivatives\\
4&Check group derivatives\\
\end{tabular}
\end{center}
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Option \%d (argument 2) is invalid, must be in range 0-4"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetCheckDerivatives}
\label{Subroutine:LNGetCheckDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot test derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it flag}=LNGetCheckDerivatives({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it flag &\parbox[t]{\SYNTAX}{How to test.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Check\-Derivatives} 
gets the parameter controlling how Lancelot test derivatives.
Legal values for the flag and their meaning --
\begin{center}
\begin{tabular}{ll}
0&No checking\\
1&Check all derivatives\\
2&Check derivatives\\
3&Check element derivatives\\
4&Check group derivatives\\
\end{tabular}
\end{center}
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetConstraintAccuracy}
\label{Subroutine:LNSetConstraintAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how accurately constraints are solved.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetConstraintAccuracy({\it Lan},{\it limit});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Constraint\-Accuracy} 
sets the parameter controlling how accurately the constraints are solved.
The default value is 0.00001.
The {\tt SPEC.SPC} file entry this corresponds to is {\tt CONSTRAINT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetConstraintAccuracy}
\label{Subroutine:LNGetConstraintAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how accurately Lancelot solves constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it limit}=LNGetConstraintAccuracy({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Constraint\-Accuracy} 
gets the parameter controlling how accurately Lancelot solves the constraints.
The default value is 0.00001.
The {\tt SPEC.SPC} file entry this gets is {\tt CONSTRAINT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetFirstConstraintAccuracy}
\label{Subroutine:LNSetFirstConstraintAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the initial accuracy Lancelot uses for the constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetFirstConstraintAccuracy({\it Lan},{\it acc});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it acc &\parbox[t]{\SYNTAX}{The accuracy.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-First\-Constraint\-Accuracy} 
sets the parameter controlling the initial accuracy Lancelot uses for the constraints.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is {\tt FIRST-CONSTRAINT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetFirstConstraintAccuracy}
\label{Subroutine:LNGetFirstConstraintAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the initial accuracy Lancelot uses for the constraints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it acc}=LNGetFirstConstraintAccuracy({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it acc &\parbox[t]{\SYNTAX}{The accuracy.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-First\-Constraint\-Accuracy} 
gets the parameter controlling the initial accuracy Lancelot uses for the constraints.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this gets is {\tt FIRST-CONSTRAINT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetFirstGradientAccuracy}
\label{Subroutine:LNSetFirstGradientAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the initial accuracy for the gradients.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetFirstGradientAccuracy({\it Lan},{\it limit});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-First\-Gradient\-Accuracy} 
sets the parameter controlling the initial accuracy for the gradients.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is {\tt FIRST-GRADIENT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetFirstGradientAccuracy}
\label{Subroutine:LNGetFirstGradientAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the initial accuracy for the gradients.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it acc}=LNGetFirstGradientAccuracy({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it acc &\parbox[t]{\SYNTAX}{The accuracy.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-First\-Gradient\-Accuracy} 
gets the parameter controlling the initial accuracy for the gradients.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this corresponds to is {\tt FIRST-GRADIENT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetGradientAccuracy}
\label{Subroutine:LNSetGradientAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the accuracy for the gradients.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetGradientAccuracy({\it Lan},{\it limit});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Gradient\-Accuracy} 
sets the parameter controlling the accuracy for the gradients.
The default value is 0.00001.
The {\tt SPEC.SPC} file entry this corresponds to is {\tt GRADIENT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetGradientAccuracy}
\label{Subroutine:LNGetGradientAccuracy}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the accuracy for the gradients.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it limit}=LNGetGradientAccuracy({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it limit &\parbox[t]{\SYNTAX}{The accuracy.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Gradient\-Accuracy} 
gets the parameter controlling the accuracy for the gradients.
The default value is 0.00001.
The {\tt SPEC.SPC} file entry this corresponds to is {\tt GRADIENT-ACCURACY-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetInitialPenalty}
\label{Subroutine:LNSetInitialPenalty}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the initial penalty.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetInitialPenalty({\it Lan},{\it penalty});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it penalty &\parbox[t]{\SYNTAX}{The penalty.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Initial\-Penalty} 
sets the parameter controlling the initial penalty.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is\hfill\break
{\tt INITIAL-PENALTY-PARAMETER}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetInitialPenalty}
\label{Subroutine:LNGetInitialPenalty}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the initial penalty.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it penalty}=LNGetInitialPenalty({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it penalty &\parbox[t]{\SYNTAX}{The penalty.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet}\-{\tt Initial}\-{\tt Penalty} 
gets the parameter controlling the initial penalty.
The default value is 0.
The {\tt SPEC.SPC} file entry this sets is\hfill\break
{\tt INITIAL-PENALTY-PARAMETER}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetMaximumNumberOfIterations}
\label{Subroutine:LNSetMaximumNumberOfIterations}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how long Lancelot runs.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetMaximumNumberOfIterations({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{Maximum number of iterations.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Maximum\-Number\-Of\-Iterations} 
sets the parameter controlling how long Lancelot runs.
The default value is 100.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetMaximumNumberOfIterations}
\label{Subroutine:LNGetMaximumNumberOfIterations}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how long Lancelot runs.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetMaximumNumberOfIterations({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{Maximum number of iterations.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Maximum\-Number\-Of\-Iterations} 
sets the parameter controlling how long Lancelot runs.
The default value is 100.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPenaltyBound}
\label{Subroutine:LNSetPenaltyBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the bound on the penalty Lancelot uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPenaltyBound({\it Lan},{\it penalty});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it penalty &\parbox[t]{\SYNTAX}{The bound.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Penalty\-Bound} 
sets the parameter controlling the bound on the penalty Lancelot uses.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is\hfill\break
{\tt DECREASE-PENALTY-PARAMETER-UNTIL}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetPenaltyBound}
\label{Subroutine:LNGetPenaltyBound}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the bound on the penalty Lancelot uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void {\it penalty}=LNGetPenaltyBound({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it penalty &\parbox[t]{\SYNTAX}{The bound.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Penalty\-Bound} 
gets the parameter controlling the bound on the penalty Lancelot uses.
The default value is 0.1.
The {\tt SPEC.SPC} file entry this sets is\hfill\break
{\tt DECREASE-PENALTY-PARAMETER-UNTIL}.\vskip .1in
\leftline{\bf Errors}
Errors return DBL\_QNAN.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPrintEvery}
\label{Subroutine:LNSetPrintEvery}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how often Lancelot prints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPrintEvery({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Print\-Every} 
sets the parameter controlling how often Lancelot prints.
The default value is 1.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetPrintEvery}
\label{Subroutine:LNGetPrintEvery}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how often Lancelot prints.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetPrintEvery({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Print\-Every} 
sets the parameter controlling how often Lancelot prints.
The default value is 1.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPrintLevel}
\label{Subroutine:LNSetPrintLevel}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how much output Lancelot produces.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPrintLevel({\it Lan},{\it level});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it level &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Print\-Level} 
\noindent Sets the parameter controlling how Lancelot how much output Lancelot produces.
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"PrintLevel \%d (argument 2) is invalid, must be nonnegative"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetPrintLevel}
\label{Subroutine:LNGetPrintLevel}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how much output Lancelot produces.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it level}=LNGetPrintLevel({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it level &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Print\-Level} 
\noindent Gets the parameter controlling how Lancelot how much output Lancelot produces.
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPrintStart}
\label{Subroutine:LNSetPrintStart}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling when Lancelot starts printing.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPrintStart({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Print\-Start} 
sets the parameter controlling when Lancelot starts printing.
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetPrintStart}
\label{Subroutine:LNGetPrintStart}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling when Lancelot starts printing.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetPrintStart({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Print\-Start} 
sets the parameter controlling when Lancelot starts printing.
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetPrintStop}
\label{Subroutine:LNSetPrintStop}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling when Lancelot stops printing.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetPrintStop({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Print\-Stop} 
sets the parameter controlling when Lancelot stops printing.
The default value is 100.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetPrintStop}
\label{Subroutine:LNGetPrintStop}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling when Lancelot stops printing.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetPrintStop({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LN\-Get\-Print\-Stop} 
sets the parameter controlling when Lancelot stops printing.
The default value is 100.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetRequireExactCauchyPoint}
\label{Subroutine:LNSetRequireExactCauchyPoint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter determining whether an exact cauchy point is required.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetRequireExactCauchyPoint({\it Lan},{\it choice});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Require\-Exact\-Cauchy\-Point} 
sets the parameter determining whether an exact cauchy point is required.
The default is 1.

The corresponding {\tt SPEC.SPC} file entries are {\tt EXACT-CAUCHY-POINT-REQUIRED}
\hfill\break
and {\tt INEXACT-CAUCHY-POINT-REQUIRED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetRequireExactCauchyPoint}
\label{Subroutine:LNGetRequireExactCauchyPoint}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter determining whether an exact cauchy point is required.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it choice}=LNGetRequireExactCauchyPoint({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Require\-Exact\-Cauchy\-Point} 
gets the parameter determining whether an exact cauchy point is required.
The default is 1.

The corresponding {\tt SPEC.SPC} file entries are {\tt EXACT-CAUCHY-POINT-REQUIRED}
\hfill\break
and {\tt INEXACT-CAUCHY-POINT-REQUIRED}.
\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetSaveDataEvery}
\label{Subroutine:LNSetSaveDataEvery}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how often Lancelot saves data.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetSaveDataEvery({\it Lan},{\it iter});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Save\-Data\-Every} 
sets the parameter controlling how often Lancelot saves data.
The default value is 0 (don't save).\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetSaveDataEvery}
\label{Subroutine:LNGetSaveDataEvery}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how often Lancelot saves data.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it iter}=LNGetSaveDataEvery({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it iter &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Save\-Data\-Every} 
sets the parameter controlling how often Lancelot saves data.
The default value is 0 (don't save).\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetScalings}
\label{Subroutine:LNSetScalings}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how Lancelot uses scalings.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetScalings({\it Lan},{\it choice});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt char&*\it choice &\parbox[t]{\SYNTAX}{How to use scalings.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Scalings} 
sets the parameter controlling how Lancelot uses scalings.

The legal values for {\it choice} and the corresponding 
{\tt SPEC.SPC} file entries are
\begin{center}
\begin{tabular}{ll}
   "no scaling"&No entry in SPEC.SPC\\
   "scale constraints"&USE-CONSTRAINT-SCALING-FACTORS\\
   "scale variables"&USE-VARIABLE-SCALING-FACTORS\\
   "scale both"&USE-SCALING-FACTORS\\
   "print but don't use"&PRINT-SCALING-FACTORS\\
\end{tabular}
\end{center}\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"Scaling "\%s" (argument 2) is invalid, must be one of "No Scaling","Scale Constraints","Scale Variables","Scale Both","Print but don't use""}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetScalings}
\label{Subroutine:LNGetScalings}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot uses scalings.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it choice}=LNGetScalings({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it choice &\parbox[t]{\SYNTAX}{How to use scalings.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Scalings} 
gets the parameter controlling how Lancelot uses scalings.

The legal values for {\it choice} and the corresponding 
{\tt SPEC.SPC} file entries are
\begin{center}
\begin{tabular}{ll}
   "no scaling"&USE-SCALING-FACTORS\\
   "scale constraints"&USE-CONSTRAINT-SCALING-FACTORS\\
   "scale variables"&USE-VARIABLE-SCALING-FACTORS\\
   "scale both"&USE-SCALING-FACTORS\\
   "print but don't use"&PRINT-SCALING-FACTORS\\
\end{tabular}
\end{center}\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetSolveBQPAccurately}
\label{Subroutine:LNSetSolveBQPAccurately}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the solution of the BQP.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetSolveBQPAccurately({\it Lan},{\it choice});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Solve\-BQP\-Accurately} 
sets the parameter controlling the solution of the BQP.
The default is 0.

The corresponding {\tt SPEC.SPC} file entry is {\tt SOLVE-BQP-ACCURATELY}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetSolveBQPAccurately}
\label{Subroutine:LNGetSolveBQPAccurately}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the solution of the BQP.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt  {\it choice}=LNGetSolveBQPAccurately({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Solve\-BQP\-Accurately} 
gets the parameter controlling the solution of the BQP.
The default is 0.

The corresponding {\tt SPEC.SPC} file entry is {\tt SOLVE-BQP-ACCURATELY}.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetLinearSolverMethod}
\label{Subroutine:LNSetLinearSolverMethod}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter determining what linear solver is used.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetLinearSolverMethod({\it Lan},{\it choice},{\it bandwidth});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt char&\it *choice &\parbox[t]{\SYNTAX}{}\\
\tt int&\it bandwidth &\parbox[t]{\SYNTAX}{Bandwidth, if choice is "bandsolver preconditioned"}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Linear\-Solver\-Method} 
sets the parameter determining what linear solver is used.

Legal values of {\it choice}, and the corresponding
{\tt SPEC.SPC} file entries are
\begin{center}
 \begin{tabular}{l}
  "Diagonal preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt DIAGONAL-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Munksgaards preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt MUNKSGAARDS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Expanding band preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt EXPANDING-BAND-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Full matrix preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt FULL-MATRIX-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Gill-Murray-Ponceleon-Saunders preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt GILL-MURRAY-PONCELEON-SAUNDERS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Modified MA27 preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt MODIFIED-MA27-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Schnabel-Eskow preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt SCHNABEL-ESKOW-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Users preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt USERS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Bandsolver preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt BANDSOLVER-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Multifront"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt MULTIFRONT-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Direct modified"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt DIRECT-MODIFIED-MULTIFRONTAL-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "CG method used"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt CG-METHOD-USED}\\
 \end{tabular}
\end{center}\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"Linear Solver Type "\%s" (argument 2) is invalid"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetLinearSolverMethod}
\label{Subroutine:LNGetLinearSolverMethod}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter determining what linear solver is used.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt int {\it choice}=LNGetLinearSolverMethod({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it choice &\parbox[t]{\SYNTAX}{}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Linear\-Solver\-Method} 
gets the parameter determining what linear solver is used.
If a banded solver is used, the bandwidth can be retrieved with the
{\tt LNGet\-Linear\-Solver\-Bandwidth} routine (page \pageref{Subroutine:LNGetLinearSolverBandwidth}).

Legal values of {\it choice}, and the corresponding
{\tt SPEC.SPC} file entries are
\begin{center}
 \begin{tabular}{l}
  "Diagonal preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt DIAGONAL-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Munksgaards preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt MUNKSGAARDS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Expanding band preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt EXPANDING-BAND-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Full matrix preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt FULL-MATRIX-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Gill-Murray-Ponceleon-Saunders preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt GILL-MURRAY-PONCELEON-SAUNDERS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Modified MA27 preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt MODIFIED-MA27-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Schnabel-Eskow preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt SCHNABEL-ESKOW-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Users preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt USERS-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Bandsolver preconditioned"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt BANDSOLVER-PRECONDITIONED-CG-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Multifront"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt MULTIFRONT-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "Direct modified"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt DIRECT-MODIFIED-MULTIFRONTAL-SOLVER-USED}\\
 \end{tabular}
\end{center}
\begin{center}
 \begin{tabular}{l}
  "CG method used"\\
  \parbox[t]{\ERRORMSG}{\hfill\tt CG-METHOD-USED}\\
 \end{tabular}
\end{center}\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetLinearSolverBandwidth}
\label{Subroutine:LNGetLinearSolverBandwidth}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter determining what bandwidth the linear solver uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it bandwidth}=LNGetLinearSolverBandwidth({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it bandwidth &\parbox[t]{\SYNTAX}{The bandwidth.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Linear\-Solver\-Bandwidth} 
gets the parameter determining what bandwidth the linear solver uses.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetStopOnBadDerivatives}
\label{Subroutine:LNSetStopOnBadDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how Lancelot deals with bad derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetStopOnBadDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Stop\-On\-Bad\-Derivatives} 
\noindent Sets the parameter controlling how Lancelot deals with bad derivatives.
Legal values for the flag and their meaning --
\begin{center}
\begin{tabular}{ll}
0&stop on warning\\
1&stop on element derivative warning\\
2&stop on group derivative warning\\
\end{tabular}
\end{center}
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Option \%d (argument 2) is invalid, must be in range 0-2"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetStopOnBadDerivatives}
\label{Subroutine:LNGetStopOnBadDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot deals with bad derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt void LNGetStopOnBadDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Stop\-On\-Bad\-Derivatives} 
\noindent Gets the parameter controlling how Lancelot deals with bad derivatives.
Legal values for the flag and their meaning --
\begin{center}
\begin{tabular}{ll}
0&stop on warning\\
1&stop on element derivative warning\\
2&stop on group derivative warning\\
\end{tabular}
\end{center}
The default value is 0.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetTrustRegionRadius}
\label{Subroutine:LNSetTrustRegionRadius}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the radius of the trust region.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetTrustRegionRadius({\it Lan},{\it radius});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt double&\it radius &\parbox[t]{\SYNTAX}{The radius.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Trust\-Region\-Radius} 
sets the parameter controlling the radius of the trust region.
The default value is 0.
The {\tt SPEC.SPC} file entry this sets is {\tt TRUST-REGION-RADIUS}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetTrustRegionRadius}
\label{Subroutine:LNGetTrustRegionRadius}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the radius of the trust region.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it radius}=LNGetTrustRegionRadius({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt double&\it radius &\parbox[t]{\SYNTAX}{The radius.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Trust\-Region\-Radius} 
gets the parameter controlling the radius of the trust region.
The default value is 0.
The {\tt SPEC.SPC} file entry this gets is {\tt TRUST-REGION-RADIUS}.\vskip .1in
\leftline{\bf Errors}
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetTrustRegionType}
\label{Subroutine:LNSetTrustRegionType}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling the type of trust region Lancelot uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetTrustRegionType({\it Lan},{\it choice});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt char&*\it choice &\parbox[t]{\SYNTAX}{Which type.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Trust\-Region\-Type} 
sets the parameter controlling the type of trust region Lancelot uses.
Legal values for the {\it choice} and their meaning --
\begin{center}
\begin{tabular}{lc}Message&Severity\\\hline
"two norm"&TWO-NORM-TRUST-REGION-USED\\
"infinity norm"&INFINITY-NORM-TRUST-REGION-USED\\
\end{tabular}
\end{center}
The default value is "infinity norm".\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"TrustRegionType "\%s" (argument 2) is invalid, must be one of "Two Norm" "Infinity Norm",choice}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetTrustRegionType}
\label{Subroutine:LNGetTrustRegionType}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling the type of trust region Lancelot uses.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it choice}=LNGetTrustRegionType({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt char&*\it choice &\parbox[t]{\SYNTAX}{Which type.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Trust\-Region\-Type} 
gets the parameter controlling the type of trust region Lancelot uses.
Legal values for the {\it choice} and their meaning --
\begin{center}
\begin{tabular}{ll}
"two norm"&TWO-NORM-TRUST-REGION-USED\\
"infinity norm"&INFINITY-NORM-TRUST-REGION-USED\\
\end{tabular}
\end{center}
The default value is "infinity norm".\vskip .1in
\leftline{\bf Errors}
Errors return (char*)NULL.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetUseExactFirstDerivatives}
\label{Subroutine:LNSetUseExactFirstDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling how Lancelot gets derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetUseExactFirstDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Use\-Exact\-First\-Derivatives} 
sets the parameter controlling how Lancelot gets derivatives. If
flag is 0, differencing is used, otherwise exact derivatives are 
expected.
The default value is 1 (exact derivatives). The {\tt SPEC.SPC} entry this
corresponds to is {\tt FINITE-DIFFERENCE-GRADIENTS}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetUseExactFirstDerivatives}
\label{Subroutine:LNGetUseExactFirstDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot gets derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it flag}=LNGetUseExactFirstDerivatives({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Use\-Exact\-First\-Derivatives} 
gets the parameter controlling how Lancelot gets derivatives. If
flag is 0, differencing is used, otherwise exact derivatives are 
expected.
The default value is 1 (exact derivatives). The {\tt SPEC.SPC} entry this
gets is the logical negative of {\tt FINITE-DIFFERENCE-GRADIENTS}.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}
\newpage
\leftline{\bf LNSetUseExactSecondDerivatives}
\label{Subroutine:LNSetUseExactSecondDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Sets the parameter controlling second derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it rc}=LNSetUseExactSecondDerivatives({\it Lan},{\it flag});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it rc &\parbox[t]{\SYNTAX}{The return code.}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\tt char&\it *flag &\parbox[t]{\SYNTAX}{What to do - one of "Exact", "BFGS","DFP","PSB", or "SR1" }\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNSet\-Use\-Exact\-Second\-Derivatives} 
sets the parameter controlling how second derivatives are handled. If
flag is 0, differencing is used, otherwise exact second derivatives are 
expected.
The default value is 1 (exact second derivatives). The {\tt SPEC.SPC} entry 
this corresponds to is {\tt EXACT-SECOND-DERIVATIVES-USED}.\vskip .1in
\leftline{\bf Errors}
Errors return 0, normal execution returns 1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\parbox[t]{\ERRORMSG}{"Out of memory, trying to allocate \%d bytes"}&12\\
\parbox[t]{\ERRORMSG}{"Option "\%s" is invalid, must be one of "Exact", "BFGS","DFP","PSB", "SR1","}&12\\
\end{tabular}
\newpage
\leftline{\bf LNGetUseExactSecondDerivatives}
\label{Subroutine:LNGetUseExactSecondDerivatives}
\vskip .5in

\leftline{\bf Purpose}
\vskip .1in
\noindent Gets the parameter controlling how Lancelot gets second derivatives.
\vskip .1in
\leftline{\bf Library}
\vskip .1in
\noindent {\tt libNLPAPI.a}
\vskip .1in

\leftline{\bf C Syntax}
\vskip .1in
\leftline{\tt \#include <NLPAPI.h>}
\leftline{\tt {\it flag}=LNGetUseExactSecondDerivatives({\it Lan});}
\vskip .1in
\begin{tabular}{lll}
\tt int&\it flag &\parbox[t]{\SYNTAX}{What to do}\\
\tt NLLancelot&\it Lan &\parbox[t]{\SYNTAX}{The solver.}\\
\end{tabular}

\vskip .1in
\leftline{\bf Description}
\vskip .1in
\noindent
The routine {\tt LNGet\-Use\-Exact\-Second\-Derivatives} 
gets the parameter controlling gets second derivatives. If
flag is 0, differencing is used, otherwise exact second derivatives are 
expected.
The default value is 1 (exact second derivatives). The {\tt SPEC.SPC} entry this
gets is {\tt EXACT-SECOND-DERIVATIVES-USED}.\vskip .1in
\leftline{\bf Errors}
Errors return -1.
\vskip .1in
\noindent
\begin{tabular}{lc}Message&Severity\\\hline
\parbox[t]{\ERRORMSG}{"Solver (argument 1) is NULL"}&12\\
\end{tabular}

\end{document}
